pipeline {
    agent any

    tools {
        maven 'maven3'
    }

    parameters {
        // Build parameters
        string(name: 'BRANCH', defaultValue: 'test1', description: 'Branch to build from')
        string(name: 'TENANT_NAME', defaultValue: '', description: 'Tenant name for deployment')
        string(name: 'APP_NAME', defaultValue: 'inventory', description: 'Application name')
        string(name: 'DO_DOMAIN', defaultValue: '', description: 'the domain')
        string(name: 'SUBSCRIPTION_TIER', defaultValue: 'BASIC', description: 'Subscription tier')
        string(name: 'BILLING_EMAIL', defaultValue: '', description: 'Billing email address')
        string(name: 'TENANT_UUID_ID', defaultValue: '', description: 'Tenant UUID ID for database record')

        // Docker parameters
        string(name: 'DOCKER_USER', defaultValue: 'techvvsadmin', description: 'Docker Hub username')

        // Application configuration parameters
        string(name: 'ENVIRONMENT_NAME', defaultValue: 'prod', description: 'Environment name (prod, dev1)')
        string(name: 'LOAD_REF_DATA', defaultValue: 'no', description: 'Load reference data (yes/no)')
        string(name: 'TAX_PERCENTAGE', defaultValue: '0', description: 'Tax percentage')
        string(name: 'MAX_FILE_SIZE', defaultValue: '500MB', description: 'Maximum file size')
        string(name: 'MAX_REQ_SIZE', defaultValue: '500MB', description: 'Maximum request size')

        // Database configuration
        string(name: 'DB_DRIVER_CLASS_NAME', defaultValue: 'org.postgresql.Driver', description: 'Database driver class')
        string(name: 'DB_JPA_DATABASE_PLATFORM', defaultValue: 'org.hibernate.dialect.PostgreSQLDialect', description: 'JPA database platform')
        string(name: 'DB_JPA_HIBERNATE_DIALECT', defaultValue: 'org.hibernate.dialect.PostgreSQLDialect', description: 'Hibernate dialect')
        string(name: 'DB_USERNAME', defaultValue: 'doadmin', description: 'Database username')
        string(name: 'SANDBOX_POSTGRESQL_URI', defaultValue: 'jdbc:postgresql://private-sandbox-cluster-do-user-1326368-0.e.db.ondigitalocean.com:25060', description: 'Database uri')
        string(name: 'DB_URI', defaultValue: 'jdbc:postgresql://private-sandbox-cluster-do-user-1326368-0.e.db.ondigitalocean.com:25060', description: 'Database uri')
        string(name: 'DB_HOST', defaultValue: 'private-sandbox-cluster-do-user-1326368-0.e.db.ondigitalocean.com', description: 'Database host')
        string(name: 'DB_PORT', defaultValue: '25060', description: 'Database port')
        string(name: 'DB_NAME', defaultValue: 'defaultdb', description: 'Database name')
        string(name: 'SPRING_DATABASE_ACTION', defaultValue: 'update', description: 'Database action (update, create-drop)')
        string(name: 'DB_H2_CONSOLE_ENABLED', defaultValue: 'false', description: 'Enable H2 console')
        string(name: 'DB_H2_WEB_ALLOWOTHERS', defaultValue: 'false', description: 'Allow others to access H2 console')

        // PayPal configuration
        string(name: 'PAYPAL_ENVIRONMENT', defaultValue: 'SANDBOX', description: 'PayPal environment (SANDBOX/PRODUCTION)')
        string(name: 'PAYPAL_BRAND_NAME', defaultValue: 'techvvs_clothing_app_1', description: 'PayPal brand name')

        // Wallet configuration
        string(name: 'WALLET_BRAND', defaultValue: 'Tulip', description: 'Wallet brand organization name')
        string(name: 'WALLET_BRAND_PROGRAM', defaultValue: 'Tulip Membership', description: 'Wallet brand program name')
        string(name: 'WALLET_GOOGLE_SERVICE_ACC_KEY_PATH', defaultValue: 'classpath:/uploads/applecert/', description: 'Google service account key path')
        string(name: 'WALLET_GOOGLE_ISSUER_ID', defaultValue: '', description: 'Google wallet issuer ID')
        string(name: 'WALLET_GOOGLE_CLASS_ID', defaultValue: '', description: 'Google wallet class ID')

        // METRC configuration
        string(name: 'METRC_MCP_FILE_PATH', defaultValue: 'classpath:/uploads/mcp/metrc-mcp-connector.dxt', description: 'METRC MCP file path')

        // Request logging configuration
        string(name: 'REQUEST_LOGGING_ENABLED', defaultValue: 'true', description: 'Enable request logging')
        string(name: 'REQUEST_LOGGING_HEADERS', defaultValue: 'true', description: 'Log request headers')
        string(name: 'REQUEST_LOGGING_DEVICE_INFO', defaultValue: 'true', description: 'Log device info')
        string(name: 'REQUEST_LOGGING_SESSION_INFO', defaultValue: 'true', description: 'Log session info')
        string(name: 'REQUEST_LOGGING_SECURITY_INFO', defaultValue: 'false', description: 'Log security info')

        // Additional parameters for deployment
        string(name: 'K8S_NAMESPACE', defaultValue: '', description: 'Kubernetes namespace for deployment')
        string(name: 'DO_LOADBALANCER_ID', defaultValue: '', description: 'DigitalOcean Load Balancer ID')
    }

    stages {
        stage('Checkout') {
            steps {
                checkout([
                    $class: 'GitSCM',
                    branches: [[name: "*/${params.BRANCH}"]],
                    userRemoteConfigs: [[url: 'https://github.com/javascriptjenkins/inventory.git', credentialsId: 'githubcreds']]
                ])
            }
        }

        stage('Log Build Parameters') {
            steps {
                script {
                    echo "=========================================="
                    echo "JENKINS BUILD PARAMETERS LOG"
                    echo "=========================================="
                    echo ""

                    echo "üìã BUILD PARAMETERS:"
                    echo "  BRANCH: ${params.BRANCH}"
                    echo "  TENANT_NAME: ${params.TENANT_NAME}"
                    echo "  APP_NAME: ${params.APP_NAME}"
                    echo "  SUBSCRIPTION_TIER: ${params.SUBSCRIPTION_TIER}"
                    echo "  BILLING_EMAIL: ${params.BILLING_EMAIL}"

                    echo "üê≥ DOCKER PARAMETERS:"
                    echo "  DOCKER_USER: ${params.DOCKER_USER}"
                    echo ""

                    echo "‚öôÔ∏è APPLICATION CONFIGURATION:"
                    echo "  ENVIRONMENT_NAME: ${params.ENVIRONMENT_NAME}"
                    echo "  LOAD_REF_DATA: ${params.LOAD_REF_DATA}"
                    echo "  TAX_PERCENTAGE: ${params.TAX_PERCENTAGE}"
                    echo "  MAX_FILE_SIZE: ${params.MAX_FILE_SIZE}"
                    echo "  MAX_REQ_SIZE: ${params.MAX_REQ_SIZE}"
                    echo ""

                    echo "üóÑÔ∏è DATABASE CONFIGURATION:"
                    echo "  DB_DRIVER_CLASS_NAME: ${params.DB_DRIVER_CLASS_NAME}"
                    echo "  DB_JPA_DATABASE_PLATFORM: ${params.DB_JPA_DATABASE_PLATFORM}"
                    echo "  DB_JPA_HIBERNATE_DIALECT: ${params.DB_JPA_HIBERNATE_DIALECT}"
                    echo "  DB_USERNAME: ${params.DB_USERNAME}"
                    echo "  SANDBOX_POSTGRESQL_URI: ${params.SANDBOX_POSTGRESQL_URI}"
                    echo "  env.DB_URI: ${env.DB_URI}"
                    echo "  SPRING_DATABASE_ACTION: ${params.SPRING_DATABASE_ACTION}"
                    echo "  DB_H2_CONSOLE_ENABLED: ${params.DB_H2_CONSOLE_ENABLED}"
                    echo "  DB_H2_WEB_ALLOWOTHERS: ${params.DB_H2_WEB_ALLOWOTHERS}"
                    echo ""

                    echo "üí≥ PAYPAL CONFIGURATION:"
                    echo "  PAYPAL_ENVIRONMENT: ${params.PAYPAL_ENVIRONMENT}"
                    echo "  PAYPAL_BRAND_NAME: ${params.PAYPAL_BRAND_NAME}"
                    echo ""

                    echo "üíõ WALLET CONFIGURATION:"
                    echo "  WALLET_BRAND: ${params.WALLET_BRAND}"
                    echo "  WALLET_BRAND_PROGRAM: ${params.WALLET_BRAND_PROGRAM}"
                    echo "  WALLET_GOOGLE_SERVICE_ACC_KEY_PATH: ${params.WALLET_GOOGLE_SERVICE_ACC_KEY_PATH}"
                    echo "  WALLET_GOOGLE_ISSUER_ID: ${params.WALLET_GOOGLE_ISSUER_ID}"
                    echo "  WALLET_GOOGLE_CLASS_ID: ${params.WALLET_GOOGLE_CLASS_ID}"
                    echo ""

                    echo "üåø METRC CONFIGURATION:"
                    echo "  METRC_MCP_FILE_PATH: ${params.METRC_MCP_FILE_PATH}"
                    echo ""

                    echo "üìä REQUEST LOGGING CONFIGURATION:"
                    echo "  REQUEST_LOGGING_ENABLED: ${params.REQUEST_LOGGING_ENABLED}"
                    echo "  REQUEST_LOGGING_HEADERS: ${params.REQUEST_LOGGING_HEADERS}"
                    echo "  REQUEST_LOGGING_DEVICE_INFO: ${params.REQUEST_LOGGING_DEVICE_INFO}"
                    echo "  REQUEST_LOGGING_SESSION_INFO: ${params.REQUEST_LOGGING_SESSION_INFO}"
                    echo "  REQUEST_LOGGING_SECURITY_INFO: ${params.REQUEST_LOGGING_SECURITY_INFO}"
                    echo ""

                    echo "=========================================="
                    echo "END OF BUILD PARAMETERS LOG"
                    echo "=========================================="
                }
            }
        }

        stage('Setup Environment Variables') {
            steps {
                script {
                    // Calculate dynamic values
                    def baseQrDomain = "https://${params.TENANT_NAME}.${params.DO_DOMAIN}"

                    // Store in environment variables for reuse
                    env.BASE_QR_DOMAIN = baseQrDomain

                    echo "=========================================="
                    echo "DYNAMIC VALUES CALCULATED DURING BUILD"
                    echo "=========================================="
                    echo "BASE_QR_DOMAIN: ${baseQrDomain}"
                    echo "METRC_MCP_URI: ${baseQrDomain}/api/mcp"
                    echo "=========================================="
                }
            }
        }

        stage('Setup Kubeconfig') {
            steps {
                script {
                    withCredentials([file(credentialsId: 'KUBECONFIG_PATH', variable: 'KUBECONFIG_FILE')]) {
                        dir('inventory') {
                            sh "mkdir -p kubeconfig"
                            sh "cp ${KUBECONFIG_FILE} kubeconfig/tulip-sandbox-kubeconfig.yaml"
                            sh "chmod 600 kubeconfig/tulip-sandbox-kubeconfig.yaml"

                            sh """
                                if [ -f "kubeconfig/tulip-sandbox-kubeconfig.yaml" ]; then
                                    echo "Kubeconfig file verified: kubeconfig/tulip-sandbox-kubeconfig.yaml"
                                else
                                    echo "ERROR: Kubeconfig file not found at expected location"
                                    exit 1
                                fi
                            """
                        }
                    }
                }
            }
        }

        stage('Update Basic App Properties') {
            steps {
                script {
                    dir('inventory') {
                        // Basic application settings
                        if (params.ENVIRONMENT_NAME) {
                            sh "sed -i 's/^spring\\.profiles\\.active=.*/spring.profiles.active=${params.ENVIRONMENT_NAME}/' src/main/resources/application.properties"
                        }
                        if (params.LOAD_REF_DATA) {
                            sh "sed -i 's/^load\\.ref\\.data=.*/load.ref.data=${params.LOAD_REF_DATA}/' src/main/resources/application.properties"
                        }
                        if (params.TAX_PERCENTAGE) {
                            sh "sed -i 's/^tax\\.percentage=.*/tax.percentage=${params.TAX_PERCENTAGE}/' src/main/resources/application.properties"
                        }
                        sh "sed -i 's|^base\\.qr\\.domain=.*|base.qr.domain=${env.BASE_QR_DOMAIN}|' src/main/resources/application.properties"
                        if (params.MAX_FILE_SIZE) {
                            sh "sed -i 's/^spring\\.servlet\\.multipart\\.max-file-size=.*/spring.servlet.multipart.max-file-size=${params.MAX_FILE_SIZE}/' src/main/resources/application.properties"
                        }
                        if (params.MAX_REQ_SIZE) {
                            sh "sed -i 's/^spring\\.servlet\\.multipart\\.max-request-size=.*/spring.servlet.multipart.max-request-size=${params.MAX_REQ_SIZE}/' src/main/resources/application.properties"
                        }
                    }
                }
            }
        }

        stage('Update Database Properties') {
            steps {
                script {
                    withCredentials([
                        string(credentialsId: 'SANDBOX_POSTGRESQL_PUBLIC_USER', variable: 'SANDBOX_POSTGRESQL_PUBLIC_USER'),
                        string(credentialsId: 'SANDBOX_POSTGRESQL_PASSWORD', variable: 'SANDBOX_POSTGRESQL_PASSWORD')
                    ]) {
                        dir('inventory') {
                            sh "sed -i 's|^spring\\.datasource\\.url=.*|spring.datasource.url=${params.DB_URI}/defaultdb?currentSchema=tenant_${params.TENANT_NAME}&sslmode=require|' src/main/resources/application.properties"
                            if (params.DB_DRIVER_CLASS_NAME) {
                                sh "sed -i 's/^spring\\.datasource\\.driver-class-name=.*/spring.datasource.driver-class-name=${params.DB_DRIVER_CLASS_NAME}/' src/main/resources/application.properties"
                            }
                            if (params.DB_JPA_DATABASE_PLATFORM) {
                                sh "sed -i 's/^spring\\.jpa\\.database-platform=.*/spring.jpa.database-platform=${params.DB_JPA_DATABASE_PLATFORM}/' src/main/resources/application.properties"
                            }
                            if (params.DB_JPA_HIBERNATE_DIALECT) {
                                sh "sed -i 's/^spring\\.jpa\\.properties\\.hibernate\\.dialect=.*/spring.jpa.properties.hibernate.dialect=${params.DB_JPA_HIBERNATE_DIALECT}/' src/main/resources/application.properties"
                            }
                            sh "sed -i 's/^spring\\.datasource\\.username=.*/spring.datasource.username=${SANDBOX_POSTGRESQL_PUBLIC_USER}/' src/main/resources/application.properties"
                            sh "sed -i 's/^spring\\.datasource\\.password=.*/spring.datasource.password=${SANDBOX_POSTGRESQL_PASSWORD}/' src/main/resources/application.properties"
                            sh "sed -i 's/^spring\\.jpa\\.properties\\.hibernate\\.default_schema=.*/spring.jpa.properties.hibernate.default_schema=${params.TENANT_NAME}/' src/main/resources/application.properties"

                            if (params.SPRING_DATABASE_ACTION) {
                                sh "sed -i 's/^spring\\.jpa\\.hibernate\\.ddl-auto=.*/spring.jpa.hibernate.ddl-auto=${params.SPRING_DATABASE_ACTION}/' src/main/resources/application.properties"
                            }
                            if (params.DB_H2_CONSOLE_ENABLED) {
                                sh "sed -i 's/^spring\\.h2\\.console\\.enabled=.*/spring.h2.console.enabled=${params.DB_H2_CONSOLE_ENABLED}/' src/main/resources/application.properties"
                            }
                            if (params.DB_H2_WEB_ALLOWOTHERS) {
                                sh "sed -i 's/^spring\\.h2\\.console\\.settings\\.web-allow-others=.*/spring.h2.console.settings.web-allow-others=${params.DB_H2_WEB_ALLOWOTHERS}/' src/main/resources/application.properties"
                            }
                        }
                    }
                }
            }
        }

        stage('Update API Keys') {
            steps {
                script {
                    withCredentials([
                        string(credentialsId: 'TWILIO_API_USER', variable: 'TWILIO_API_USER'),
                        string(credentialsId: 'TWILIO_API_PASSWORD', variable: 'TWILIO_API_PASSWORD'),
                        string(credentialsId: 'SENDGRID_API_KEY', variable: 'SENDGRID_API_KEY'),
                        string(credentialsId: 'JWT_SECRET_KEY', variable: 'JWT_SECRET_KEY'),
                        string(credentialsId: 'ANTHROPIC_API_KEY', variable: 'ANTHROPIC_API_KEY')
                    ]) {
                        dir('inventory') {
                            sh "sed -i 's|^twilio\\.api\\.username=.*|twilio.api.username=${TWILIO_API_USER}|' src/main/resources/application.properties"
                            sh "sed -i 's|^twilio\\.api\\.password=.*|twilio.api.password=${TWILIO_API_PASSWORD}|' src/main/resources/application.properties"
                            sh "sed -i 's|^sendgrid\\.api\\.key=.*|sendgrid.api.key=${SENDGRID_API_KEY}|' src/main/resources/application.properties"
                            sh "sed -i 's|^security\\.jwt\\.token\\.secret-key=.*|security.jwt.token.secret-key=${JWT_SECRET_KEY}|' src/main/resources/application.properties"
                            sh "sed -i 's|^anthropic\\.apiKey=.*|anthropic.apiKey=${ANTHROPIC_API_KEY}|' src/main/resources/application.properties"
                        }
                    }
                }
            }
        }

        stage('Update Payment & METRC Properties') {
            steps {
                script {
                    withCredentials([
                        string(credentialsId: 'METRC_API_KEY_USERNAME', variable: 'METRC_API_KEY_USERNAME'),
                        string(credentialsId: 'METRC_API_KEY_PASSWORD', variable: 'METRC_API_KEY_PASSWORD'),
                        string(credentialsId: 'PAYPAL_CLIENT_ID', variable: 'PAYPAL_CLIENT_ID'),
                        string(credentialsId: 'PAYPAL_CLIENT_SECRET', variable: 'PAYPAL_CLIENT_SECRET')
                    ]) {
                        dir('inventory') {
                            sh "sed -i 's|^metrc\\.api-key-username=.*|metrc.api-key-username=${METRC_API_KEY_USERNAME}|' src/main/resources/application.properties"
                            sh "sed -i 's|^metrc\\.api-key-password=.*|metrc.api-key-password=${METRC_API_KEY_PASSWORD}|' src/main/resources/application.properties"
                            sh "sed -i 's|^paypal\\.client-id=.*|paypal.client-id=${PAYPAL_CLIENT_ID}|' src/main/resources/application.properties"
                            sh "sed -i 's|^paypal\\.client-secret=.*|paypal.client-secret=${PAYPAL_CLIENT_SECRET}|' src/main/resources/application.properties"

                            if (params.PAYPAL_ENVIRONMENT) {
                                sh "sed -i 's/^paypal\\.environment=.*/paypal.environment=${params.PAYPAL_ENVIRONMENT}/' src/main/resources/application.properties"
                            }
                            if (params.PAYPAL_BRAND_NAME) {
                                sh "sed -i 's/^paypal\\.brand-name=.*/paypal.brand-name=${params.PAYPAL_BRAND_NAME}/' src/main/resources/application.properties"
                            }

                            if (params.METRC_MCP_FILE_PATH) {
                                sh "sed -i 's|^metrc\\.mcp\\.dxtPath=.*|metrc.mcp.dxtPath=${params.METRC_MCP_FILE_PATH}|' src/main/resources/application.properties"
                            }
                            sh "sed -i 's|^metrc\\.mcp\\.url=.*|metrc.mcp.url=${env.BASE_QR_DOMAIN}/api/mcp|' src/main/resources/application.properties"
                        }
                    }
                }
            }
        }

        stage('Update Wallet Configuration') {
            steps {
                script {
                    dir('inventory') {
                        if (params.WALLET_BRAND) {
                            sh "sed -i 's/^wallet\\.brand\\.organizationName=.*/wallet.brand.organizationName=${params.WALLET_BRAND}/' src/main/resources/application.properties"
                        }
                        if (params.WALLET_BRAND_PROGRAM) {
                            sh "sed -i 's/^wallet\\.brand\\.programName=.*/wallet.brand.programName=${params.WALLET_BRAND_PROGRAM}/' src/main/resources/application.properties"
                        }
                        if (params.WALLET_GOOGLE_SERVICE_ACC_KEY_PATH) {
                            sh "sed -i 's|^wallet\\.google\\.serviceAccountKeyPath=.*|wallet.google.serviceAccountKeyPath=${params.WALLET_GOOGLE_SERVICE_ACC_KEY_PATH}|' src/main/resources/application.properties"
                        }
                        if (params.WALLET_GOOGLE_ISSUER_ID) {
                            sh "sed -i 's/^wallet\\.google\\.issuerId=.*/wallet.google.issuerId=${params.WALLET_GOOGLE_ISSUER_ID}/' src/main/resources/application.properties"
                        }
                        if (params.WALLET_GOOGLE_CLASS_ID) {
                            sh "sed -i 's/^wallet\\.google\\.classId=.*/wallet.google.classId=${params.WALLET_GOOGLE_CLASS_ID}/' src/main/resources/application.properties"
                        }
                    }
                }
            }
        }

        stage('Update Infrastructure Properties') {
            steps {
                script {
                    withCredentials([
                        string(credentialsId: 'DO_API_TOKEN', variable: 'DO_API_TOKEN'),
                        string(credentialsId: 'DO_LB_IP', variable: 'DO_LB_IP'),
                        string(credentialsId: 'SANDBOX_POSTGRESQL_PUBLIC_USER', variable: 'SANDBOX_POSTGRESQL_PUBLIC_USER'),
                        string(credentialsId: 'SANDBOX_POSTGRESQL_PUBLIC_URI', variable: 'SANDBOX_POSTGRESQL_PUBLIC_URI'),
                        string(credentialsId: 'SANDBOX_POSTGRESQL_PASSWORD', variable: 'SANDBOX_POSTGRESQL_PASSWORD'),
                        string(credentialsId: 'JENKINS_USERNAME', variable: 'JENKINS_USERNAME'),
                        string(credentialsId: 'JENKINS_API_TOKEN', variable: 'JENKINS_API_TOKEN')
                    ]) {
                        dir('inventory') {
                            // Digital Ocean configuration
                            sh "sed -i 's|^digitalocean\\.api\\.token=.*|digitalocean.api.token=${DO_API_TOKEN}|' src/main/resources/application.properties"
                            sh "sed -i 's|^digitalocean\\.domain=.*|digitalocean.domain=${params.DO_DOMAIN}|' src/main/resources/application.properties"
                            sh "sed -i 's|^digitalocean\\.target\\.loadbalancer=.*|digitalocean.target.loadbalancer=${DO_LB_IP}|' src/main/resources/application.properties"
                            sh "sed -i 's|^digitalocean\\.postgresql\\.username=.*|digitalocean.postgresql.username=${SANDBOX_POSTGRESQL_PUBLIC_USER}|' src/main/resources/application.properties"
                            sh "sed -i 's|^digitalocean\\.postgresql\\.password=.*|digitalocean.postgresql.password=${SANDBOX_POSTGRESQL_PASSWORD}|' src/main/resources/application.properties"
                            sh "sed -i 's|^digitalocean\\.postgresql\\.uri=.*|digitalocean.postgresql.uri=${SANDBOX_POSTGRESQL_PUBLIC_URI}|' src/main/resources/application.properties"

                            // Jenkins configuration
                            sh "sed -i 's|^jenkins\\.username=.*|jenkins.username=${JENKINS_USERNAME}|' src/main/resources/application.properties"
                            sh "sed -i 's|^jenkins\\.token=.*|jenkins.token=${JENKINS_API_TOKEN}|' src/main/resources/application.properties"

                            // Update kubeconfig path
                            sh "sed -i 's|^kubernetes\\.kubeconfig\\.path=.*|kubernetes.kubeconfig.path=file:/app/kubeconfig/tulip-sandbox-kubeconfig.yaml|' src/main/resources/application.properties"

                            sh """
                                echo "=== SCHEMA CONFIGURATION VERIFICATION ==="
                                grep "default_schema" src/main/resources/application.properties || echo "ERROR: default_schema not found!"
                            """
                        }
                    }
                }
            }
        }

        stage('Replace Localhost URLs') {
            steps {
                script {
                    dir('inventory') {
                        // Build the base URL for the tenant
                        def baseUrl = "https://${params.TENANT_NAME}.${params.DO_DOMAIN}"
                        
                        echo "Replacing localhost:8080 URLs with: ${baseUrl}"
                        
                        // Find all files in src/main/java and src/main/resources and replace occurrences
                        sh """
                            find src/main/java src/main/resources -type f -exec sed -i 's|http://localhost:8080|${baseUrl}|g' {} +
                        """
                        
                        // Update the local METRC MCP connector file with the actual domain
                        sh """
                            if [ -f "uploads/mcp/local-metrcdocs-connector.dxt" ]; then
                                sed -i 's|"url": "http://localhost:8080/api/mcp"|"url": "${baseUrl}/api/mcp"|g' uploads/mcp/local-metrcdocs-connector.dxt
                                echo "Updated local-metrcdocs-connector.dxt with domain: ${baseUrl}"
                            else
                                echo "Warning: local-metrcdocs-connector.dxt not found in uploads/mcp/"
                            fi
                        """
                        
                        echo "URL replacement completed successfully"
                    }
                }
            }
        }

        stage('Build Application') {
            steps {
                dir('inventory') {
                    sh 'mvn clean package -DskipTests'
                }
            }
        }

        stage('Build Docker Image') {
            steps {
                script {
                    def imageName = "${params.DOCKER_USER}/inventory-${params.TENANT_NAME}-${params.APP_NAME}:${UUID.randomUUID().toString()}".toLowerCase()
                    def jarFile = "inventory/target/inventory-0.0.1-SNAPSHOT.jar"

                    // Log Docker build information
                    echo "=========================================="
                    echo "DOCKER BUILD INFORMATION"
                    echo "=========================================="
                    echo ""
                    echo "√∞≈∏¬≥ DOCKER CONFIGURATION:"
                    echo "  DOCKER_USER: ${params.DOCKER_USER}"
                    echo "  TENANT_NAME: ${params.TENANT_NAME}"
                    echo "  APP_NAME: ${params.APP_NAME}"
                    echo "  IMAGE_NAME: ${imageName}"
                    echo "  JAR_FILE: ${jarFile}"
                    echo ""
                    echo "=========================================="
                    echo "END OF DOCKER BUILD INFORMATION"
                    echo "=========================================="

                    // Create Dockerfile with kubeconfig path
                    sh """
                        # Check if kubeconfig was created successfully
                        if [ -f inventory/kubeconfig/tulip-sandbox-kubeconfig.yaml ]; then
                            echo "Kubeconfig file found at: inventory/kubeconfig/tulip-sandbox-kubeconfig.yaml"
                            ls -la inventory/kubeconfig/
                        else
                            echo "ERROR: Kubeconfig file not found at expected location"
                            echo "Checking inventory directory:"
                            ls -la inventory/ || echo "Inventory directory does not exist"
                            exit 1
                        fi
                    """

                    // Create Dockerfile
                    writeFile file: 'Dockerfile', text: """
FROM openjdk:17-jdk-slim

# Install curl for debugging and health checks
RUN apt-get update && apt-get install -y curl && rm -rf /var/lib/apt/lists/*

# Set working directory
WORKDIR /app

# Copy the JAR file
COPY ${jarFile} app.jar

# Copy the kubeconfig file
COPY inventory/kubeconfig/tulip-sandbox-kubeconfig.yaml /app/kubeconfig/tulip-sandbox-kubeconfig.yaml

# Create necessary directories
RUN mkdir -p /app/logs /app/data /app/uploads /app/kubeconfig

# Expose port
EXPOSE 8080

# Set environment variables
ENV SPRING_PROFILES_ACTIVE=${params.ENVIRONMENT_NAME}
ENV SERVER_PORT=8080

# Run the application
CMD ["java", "-jar", "app.jar"]
"""

                    // Build Docker image
                    docker.build(imageName)

                    // Store image name for later use
                    env.DOCKER_IMAGE = imageName
                }
            }
        }

        stage('Push Docker Image') {
            steps {
                script {
                    withCredentials([string(credentialsId: 'DOCKER_TOKEN', variable: 'DOCKER_TOKEN')]) {
                        sh """
                            echo "$DOCKER_TOKEN" | docker login -u ${params.DOCKER_USER} --password-stdin
                            docker push ${env.DOCKER_IMAGE}
                        """
                    }
                }
            }
        }

        stage('Store Build Artifacts') {
            steps {
                script {
                    // Create a file with the Docker image name and other build info for the deploy pipeline
                    writeFile file: 'build-artifacts.properties', text: """
DOCKER_IMAGE=${env.DOCKER_IMAGE}
TENANT_NAME=${params.TENANT_NAME}
APP_NAME=${params.APP_NAME}
DO_DOMAIN=${params.DO_DOMAIN}
ENVIRONMENT_NAME=${params.ENVIRONMENT_NAME}
BASE_QR_DOMAIN=${env.BASE_QR_DOMAIN}
BUILD_NUMBER=${BUILD_NUMBER}
BUILD_TIMESTAMP=${new Date().format('yyyy-MM-dd HH:mm:ss')}
"""

                    // Archive the build artifacts file
                    archiveArtifacts artifacts: 'build-artifacts.properties', fingerprint: true

                    echo "Build artifacts stored. Docker image: ${env.DOCKER_IMAGE}"
                }
            }
        }

        stage('Create Database Schema') {
            when {
                expression { params.TENANT_NAME != '' }
            }
            steps {
                script {
                    echo "Creating database schema for tenant: ${params.TENANT_NAME}"
                    echo "Database connection details:"
                    echo "  Host: ${params.DB_HOST}"
                    echo "  Port: ${params.DB_PORT}"
                    echo "  Username: ${params.DB_USERNAME}"
                    echo "  Database: ${params.DB_NAME}"
                    echo "  Password: [FROM JENKINS CREDENTIAL]"
                    
                    // Connect to PostgreSQL using Jenkins credentials
                    withCredentials([string(credentialsId: 'SANDBOX_POSTGRESQL_PASSWORD', variable: 'DB_PASSWORD')]) {
                        sh """
                            echo "Testing database connection..."
                            echo "Credential length: \${#DB_PASSWORD}"
                            
                            # Test basic connection first
                            export PGPASSWORD='\${DB_PASSWORD}'
                            
                            # Try to connect with SSL and show connection info
                            psql -h ${params.DB_HOST} -p ${params.DB_PORT} -U ${params.DB_USERNAME} -d ${params.DB_NAME} --set=sslmode=require -c "SELECT current_user, current_database(), version();" || {
                                echo "Database connection failed. Possible issues:"
                                echo "1. Incorrect password in Jenkins credential 'SANDBOX_POSTGRESQL_PASSWORD'"
                                echo "2. Database server not allowing connections from Jenkins IP"
                                echo "3. Database server requires SSL connection"
                                echo "4. Firewall blocking connection"
                                exit 1
                            }
                            
                            echo "Database connection successful, creating schema..."
                            
                            # Create schema with SSL
                            psql -h ${params.DB_HOST} -p ${params.DB_PORT} -U ${params.DB_USERNAME} -d ${params.DB_NAME} --set=sslmode=require -c "
                            DO \\\$\\\$
                            BEGIN
                                IF NOT EXISTS (SELECT 1 FROM information_schema.schemata WHERE schema_name = '${params.TENANT_NAME}') THEN
                                    CREATE SCHEMA ${params.TENANT_NAME};
                                    RAISE NOTICE 'Schema ${params.TENANT_NAME} created successfully';
                                ELSE
                                    RAISE NOTICE 'Schema ${params.TENANT_NAME} already exists';
                                END IF;
                            END \\\$\\\$;
                            "
                        """
                    }
                    
                    echo "Database schema check/creation completed for tenant: ${params.TENANT_NAME}"
                }
            }
        }

        stage('Create Tenant Record') {
            when {
                expression { params.TENANT_NAME != '' && params.BILLING_EMAIL != '' && params.TENANT_UUID_ID != '' }
            }
            steps {
                script {
                    echo "Creating tenant record for: ${params.TENANT_NAME}"
                    echo "Billing email: ${params.BILLING_EMAIL}"
                    echo "Tenant UUID: ${params.TENANT_UUID_ID}"
                    
                    // Check if tenant record exists and create if it doesn't
                    withCredentials([string(credentialsId: 'SANDBOX_POSTGRESQL_PASSWORD', variable: 'DB_PASSWORD')]) {
                        sh """
                            export PGPASSWORD='\${DB_PASSWORD}'
                            psql -h ${params.DB_HOST} -p ${params.DB_PORT} -U ${params.DB_USERNAME} -d ${params.DB_NAME} --set=sslmode=require -c "
                            DO \\\$\\\$
                            DECLARE
                                tenant_exists INTEGER;
                            BEGIN
                                -- Check if tenant record exists
                                SELECT COUNT(*) INTO tenant_exists 
                                FROM tenants 
                                WHERE billing_email = '${params.BILLING_EMAIL}';
                                
                                IF tenant_exists = 0 THEN
                                    -- Insert new tenant record
                                    INSERT INTO tenants (
                                        id,
                                        tenant_name,
                                        domain_name,
                                        subscription_tier,
                                        status,
                                        billing_email,
                                        deployflag,
                                        delete_flag,
                                        admin_user_created_flag,
                                        create_time_stamp,
                                        update_time_stamp,
                                        created_at
                                    ) VALUES (
                                        '${params.TENANT_UUID_ID}'::uuid,
                                        '${params.TENANT_NAME}',
                                        '${params.DO_DOMAIN}',
                                        '${params.SUBSCRIPTION_TIER}',
                                        'active',
                                        '${params.BILLING_EMAIL}',
                                        0,
                                        0,
                                        0,
                                        NOW(),
                                        NOW(),
                                        NOW()
                                    );
                                    
                                    RAISE NOTICE 'Tenant record created successfully for: ${params.TENANT_NAME}';
                                ELSE
                                    RAISE NOTICE 'Tenant record already exists for billing email: ${params.BILLING_EMAIL}';
                                END IF;
                            END \\\$\\\$;
                            "
                        """
                    }
                    
                    echo "Tenant record check/creation completed for: ${params.TENANT_NAME}"
                }
            }
        }

        stage('Trigger Deployment') {
            when {
                expression { params.TENANT_NAME != '' && params.DO_DOMAIN != '' }
            }
            steps {
                script {
                    echo "Triggering deployment pipeline for tenant: ${params.TENANT_NAME}"

                    // Trigger the deployment pipeline
                    build job: 'docker-part2',
                          parameters: [
                              string(name: 'DOCKER_IMAGE', value: env.DOCKER_IMAGE),
                              string(name: 'BUILD_JOB_NAME', value: env.JOB_NAME),
                              string(name: 'BUILD_NUMBER', value: env.BUILD_NUMBER),
                              string(name: 'TENANT_NAME', value: params.TENANT_NAME),
                              string(name: 'APP_NAME', value: params.APP_NAME),
                              string(name: 'DO_DOMAIN', value: params.DO_DOMAIN),
                              string(name: 'ENVIRONMENT_NAME', value: params.ENVIRONMENT_NAME),
                              string(name: 'K8S_NAMESPACE', value: params.K8S_NAMESPACE ?: ''),
                              string(name: 'DO_LOADBALANCER_ID', value: params.DO_LOADBALANCER_ID ?: '')
                          ],
                          wait: true

                    echo "Deployment pipeline completed successfully"
                }
            }
        }
    }

    post {
        success {
            echo "Build completed successfully for tenant: ${params.TENANT_NAME}"
            echo "Docker image: ${env.DOCKER_IMAGE}"
            echo "Build artifacts stored for deployment pipeline"
        }
        failure {
            echo "Build failed for tenant: ${params.TENANT_NAME}"
        }
        always {
            // Clean up temporary files
            sh 'rm -f Dockerfile'
        }
    }
}