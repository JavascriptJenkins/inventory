pipeline {
    agent any

    parameters {
        // Build reference parameters
        string(name: 'BUILD_JOB_NAME', defaultValue: '', description: 'Name of the build job to deploy from')
        string(name: 'BUILD_NUMBER', defaultValue: '', description: 'Build number to deploy')
        string(name: 'DOCKER_IMAGE', defaultValue: '', description: 'Docker image to deploy (if not using build artifacts)')

        // Deployment parameters
        string(name: 'TENANT_NAME', defaultValue: '', description: 'Tenant name for deployment')
        string(name: 'APP_NAME', defaultValue: 'inventory', description: 'Application name')
        string(name: 'DO_DOMAIN', defaultValue: '', description: 'The domain')
        string(name: 'K8S_NAMESPACE', defaultValue: '', description: 'Kubernetes namespace (auto-generated if empty)')

        // DigitalOcean parameters
        string(name: 'DO_LOADBALANCER_ID', defaultValue: '', description: 'DigitalOcean Load Balancer ID for Kubernetes Service annotation')
        string(name: 'ENVIRONMENT_NAME', defaultValue: 'prod', description: 'Environment name (prod, dev1)')
    }

    stages {
        stage('Load Build Artifacts') {
            when {
                expression { params.BUILD_JOB_NAME != '' && params.BUILD_NUMBER != '' }
            }
            steps {
                script {
                    echo "Loading build artifacts from job: ${params.BUILD_JOB_NAME}, build: ${params.BUILD_NUMBER}"
                    echo "Note: Copy Artifacts plugin not available, will use parameters directly"

                    // Since copyArtifacts is not available, we'll skip artifact loading
                    // and rely on parameters passed from the build job
                    echo "Skipping artifact copy - using parameters from build job"
                }
            }
        }

        stage('Validate Parameters') {
            steps {
                script {
                    // Use parameters if build artifacts not loaded
                    if (!env.DOCKER_IMAGE) {
                        env.DOCKER_IMAGE = params.DOCKER_IMAGE
                    }
                    if (!env.TENANT_NAME) {
                        env.TENANT_NAME = params.TENANT_NAME
                    }
                    if (!env.APP_NAME) {
                        env.APP_NAME = params.APP_NAME
                    }
                    if (!env.DO_DOMAIN) {
                        env.DO_DOMAIN = params.DO_DOMAIN
                    }
                    if (!env.ENVIRONMENT_NAME) {
                        env.ENVIRONMENT_NAME = params.ENVIRONMENT_NAME
                    }

                    // Validate required parameters
                    if (!env.DOCKER_IMAGE) {
                        error "DOCKER_IMAGE is required. Provide either BUILD_JOB_NAME/BUILD_NUMBER or DOCKER_IMAGE parameter."
                    }
                    if (!env.TENANT_NAME) {
                        error "TENANT_NAME is required"
                    }
                    if (!env.DO_DOMAIN) {
                        error "DO_DOMAIN is required"
                    }

                    echo "Deployment parameters validated:"
                    echo "  DOCKER_IMAGE: ${env.DOCKER_IMAGE}"
                    echo "  TENANT_NAME: ${env.TENANT_NAME}"
                    echo "  APP_NAME: ${env.APP_NAME}"
                    echo "  DO_DOMAIN: ${env.DO_DOMAIN}"
                    echo "  ENVIRONMENT_NAME: ${env.ENVIRONMENT_NAME}"
                }
            }
        }

        stage('Setup Kubernetes Namespace') {
            steps {
                script {
                    def k8sNamespace = (params.K8S_NAMESPACE && params.K8S_NAMESPACE.trim() != '') ?
                        params.K8S_NAMESPACE :
                        "tenant-${env.TENANT_NAME.toLowerCase().replaceAll('[^a-z0-9-]', '-')}"

                    // Bind into an env var so subsequent stages can use it
                    env.K8S_NAMESPACE = k8sNamespace

                    echo "Namespace set to: ${env.K8S_NAMESPACE}"
                    echo "Constructed Kubernetes namespace: ${k8sNamespace}"
                    echo "TENANT_NAME parameter: ${env.TENANT_NAME}"
                    echo "K8S_NAMESPACE parameter: '${params.K8S_NAMESPACE}'"
                    echo "K8S_NAMESPACE parameter length: ${params.K8S_NAMESPACE?.length() ?: 'null'}"
                    echo "Workspace directory: ${WORKSPACE}"
                    echo "LoadBalancer name (workspace root): ${WORKSPACE.split('/').last()}"
                }
            }
        }

        stage('Create Deployment Manifest') {
            steps {
                script {
                    def deploymentYaml = """
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: inventory-${env.TENANT_NAME}-uploads-pvc
  namespace: ${env.K8S_NAMESPACE}
  labels:
    app: inventory
    tenant: ${env.TENANT_NAME}
spec:
  accessModes: [ReadWriteOnce]
  resources:
    requests:
      storage: 10Gi
  storageClassName: do-block-storage
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: inventory-${env.TENANT_NAME}
  namespace: ${env.K8S_NAMESPACE}
  labels:
    app: inventory
    tenant: ${env.TENANT_NAME}
spec:
  replicas: 1
  selector:
    matchLabels:
      app: inventory
      tenant: ${env.TENANT_NAME}
  template:
    metadata:
      labels:
        app: inventory
        tenant: ${env.TENANT_NAME}
    spec:
      serviceAccountName: ${env.TENANT_NAME}-admin
      containers:
      - name: inventory
        image: ${env.DOCKER_IMAGE}
        ports:
        - containerPort: 8080
        env:
        - name: SPRING_PROFILES_ACTIVE
          value: "${env.ENVIRONMENT_NAME}"
        - name: SERVER_PORT
          value: "8080"
        resources:
          requests:
            memory: "512Mi"
            cpu: "250m"
          limits:
            memory: "1Gi"
            cpu: "500m"
        volumeMounts:
        - name: logs
          mountPath: /app/logs
        - name: data
          mountPath: /app/data
        - name: uploads
          mountPath: /uploads
      volumes:
      - name: logs
        emptyDir: {}
      - name: data
        emptyDir: {}
      - name: uploads
        persistentVolumeClaim:
          claimName: inventory-${env.TENANT_NAME}-uploads-pvc
---
apiVersion: v1
kind: Service
metadata:
  name: inventory-${env.TENANT_NAME}-service
  namespace: ${env.K8S_NAMESPACE}
  labels:
    app: inventory
    tenant: ${env.TENANT_NAME}
  annotations:
    service.beta.kubernetes.io/do-loadbalancer-tls-passthrough: "true"
    service.beta.kubernetes.io/do-loadbalancer-healthcheck-protocol: "http"
    service.beta.kubernetes.io/do-loadbalancer-healthcheck-port: "8080"
    service.beta.kubernetes.io/do-loadbalancer-healthcheck-check-interval-seconds: "10"
    service.beta.kubernetes.io/do-loadbalancer-healthcheck-response-timeout-seconds: "5"
    service.beta.kubernetes.io/do-loadbalancer-healthcheck-healthy-threshold: "3"
    service.beta.kubernetes.io/do-loadbalancer-healthcheck-unhealthy-threshold: "3"
    service.beta.kubernetes.io/do-loadbalancer-type: "REGIONAL"
spec:
  type: LoadBalancer
  externalTrafficPolicy: Local
  selector:
    app: inventory
    tenant: ${env.TENANT_NAME}
  ports:
  - name: http
    port: 80
    targetPort: 8080
    protocol: TCP
  - name: https
    port: 443
    targetPort: 8080
    protocol: TCP
"""

                    // Write deployment manifest to file
                    writeFile file: 'k8s-deployment.yaml', text: deploymentYaml
                    echo "Kubernetes deployment manifest created"
                }
            }
        }

        stage('Cleanup Existing Services') {
            steps {
                script {
                    withCredentials([file(credentialsId: 'KUBECONFIG_PATH', variable: 'KCFG')]) {
                        sh """
                            export KUBECONFIG="\$KCFG"

                            # Verify kubectl can connect to the cluster
                            kubectl config get-contexts

                            # Force delete and recreate service to remove stale LoadBalancer annotations
                            echo "Force deleting any existing service with stale LoadBalancer annotations..."

                            # Force delete the existing service completely
                            echo "Deleting existing service: inventory-${env.TENANT_NAME}-service"
                            kubectl delete service inventory-${env.TENANT_NAME}-service -n ${env.K8S_NAMESPACE} --ignore-not-found=true

                            # Wait for complete deletion
                            echo "Waiting for service deletion to complete..."
                            sleep 10

                            # Verify service is gone
                            if kubectl get service inventory-${env.TENANT_NAME}-service -n ${env.K8S_NAMESPACE} >/dev/null 2>&1; then
                                echo "Service still exists, waiting longer..."
                                sleep 20

                                # Try force delete again if still exists
                                kubectl delete service inventory-${env.TENANT_NAME}-service -n ${env.K8S_NAMESPACE} --force --grace-period=0 || true
                                sleep 5
                            fi

                            echo "Service cleanup completed, ready to create fresh service"
                            kubectl cluster-info
                        """
                    }
                }
            }
        }

        stage('Verify Service Account') {
            steps {
                script {
                    withCredentials([file(credentialsId: 'KUBECONFIG_PATH', variable: 'KCFG')]) {
                        sh """
                            export KUBECONFIG="\$KCFG"

                            # Check if the service account exists in the namespace
                            echo "DEBUG: K8S_NAMESPACE variable = ${env.K8S_NAMESPACE}"
                            echo "Checking for service account ${env.TENANT_NAME}-admin in namespace ${env.K8S_NAMESPACE}"
                            kubectl get serviceaccount ${env.TENANT_NAME}-admin -n ${env.K8S_NAMESPACE} || {
                                echo "ERROR: Service account ${env.TENANT_NAME}-admin not found in namespace ${env.K8S_NAMESPACE}"
                                echo "Available service accounts in namespace ${env.K8S_NAMESPACE}:"
                                kubectl get serviceaccounts -n ${env.K8S_NAMESPACE}
                                exit 1
                            }
                        """
                    }
                }
            }
        }

        stage('Apply Kubernetes Deployment') {
            steps {
                script {
                    withCredentials([file(credentialsId: 'KUBECONFIG_PATH', variable: 'KCFG')]) {
                        sh """
                            export KUBECONFIG="\$KCFG"

                            # Apply the deployment
                            kubectl apply -f k8s-deployment.yaml
                            kubectl rollout status deployment/inventory-${env.TENANT_NAME} -n ${env.K8S_NAMESPACE} --timeout=300s
                        """
                    }
                }
            }
        }

        stage('Verify Deployment Status') {
            steps {
                script {
                    withCredentials([file(credentialsId: 'KUBECONFIG_PATH', variable: 'KCFG')]) {
                        sh """
                            export KUBECONFIG="\$KCFG"

                            # Debug: Check service configuration and load balancer details
                            echo "=== Service Configuration ==="
                            kubectl get service inventory-${env.TENANT_NAME}-service -n ${env.K8S_NAMESPACE} -o yaml

                            echo "=== Load Balancer ID ==="
                            LB_ID=\$(kubectl get service inventory-${env.TENANT_NAME}-service -n ${env.K8S_NAMESPACE} -o jsonpath='{.metadata.annotations.kubernetes\\.digitalocean\\.com/load-balancer-id}')
                            echo "Load Balancer ID: \$LB_ID"

                            echo "=== Node Information ==="
                            kubectl get nodes -o wide

                            echo "=== Pod Status ==="
                            kubectl get pods -n ${env.K8S_NAMESPACE} -o wide

                            echo "=== PVC Status ==="
                            kubectl get pvc -n ${env.K8S_NAMESPACE}

                            echo "=== PVC Details ==="
                            kubectl describe pvc inventory-${env.TENANT_NAME}-uploads-pvc -n ${env.K8S_NAMESPACE}
                        """
                    }
                }
            }
        }

        stage('Verify PVC Mount in Application Pod') {
            steps {
                script {
                    withCredentials([file(credentialsId: 'KUBECONFIG_PATH', variable: 'KCFG')]) {
                        sh """
                            export KUBECONFIG="\$KCFG"

                            echo "=========================================="
                            echo "VERIFYING PVC MOUNT IN APPLICATION POD"
                            echo "=========================================="

                            # Wait for the application pod to be ready
                            echo "â³ Waiting for application pod to be ready..."
                            kubectl wait --for=condition=Ready pod -l app=inventory,tenant=${env.TENANT_NAME} -n ${env.K8S_NAMESPACE} --timeout=300s

                            # Get the pod name
                            POD_NAME=\$(kubectl get pods -l app=inventory,tenant=${env.TENANT_NAME} -n ${env.K8S_NAMESPACE} -o jsonpath='{.items[0].metadata.name}')
                            echo "ðŸ“¦ Application pod name: \$POD_NAME"

                            # Check if the uploads directory is mounted
                            echo "ðŸ“ Checking uploads directory mount in application pod:"
                            kubectl exec \$POD_NAME -n ${env.K8S_NAMESPACE} -- ls -la /uploads/ || echo "âŒ /uploads directory not found or not accessible"

                            # Check if files from PVC are visible in the application pod
                            echo "ðŸ“„ Checking if PVC files are visible in application pod:"
                            kubectl exec \$POD_NAME -n ${env.K8S_NAMESPACE} -- find /uploads -type f -exec ls -lh {} \\; || echo "âŒ No files found in /uploads"

                            # Test write access in the application pod
                            echo "ðŸ§ª Testing write access in application pod:"
                            kubectl exec \$POD_NAME -n ${env.K8S_NAMESPACE} -- sh -c 'echo "Application pod test file created at \$(date)" > /uploads/app-pod-test.txt'
                            kubectl exec \$POD_NAME -n ${env.K8S_NAMESPACE} -- cat /uploads/app-pod-test.txt

                            echo "=========================================="
                            echo "PVC MOUNT VERIFICATION COMPLETE"
                            echo "=========================================="
                        """
                    }
                }
            }
        }

        stage('Copy Static Files to PVC') {
            steps {
                script {
                    withCredentials([file(credentialsId: 'KUBECONFIG_PATH', variable: 'KCFG')]) {
                        // Create a temporary pod to copy files to the PVC
                        def tempPodYaml = """
apiVersion: v1
kind: Pod
metadata:
  name: file-copy-pod-${env.TENANT_NAME}
  namespace: ${env.K8S_NAMESPACE}
  labels:
    app: file-copy
    tenant: ${env.TENANT_NAME}
spec:
  restartPolicy: Never
  containers:
  - name: file-copy
    image: alpine:latest
    command: ["/bin/sh", "-c", "sleep 3600"]
    volumeMounts:
    - name: uploads
      mountPath: /uploads
  volumes:
  - name: uploads
    persistentVolumeClaim:
      claimName: inventory-${env.TENANT_NAME}-uploads-pvc
"""

                        // Write temporary pod manifest
                        writeFile file: 'file-copy-pod.yaml', text: tempPodYaml

                        sh """
                            export KUBECONFIG="\$KCFG"

                            # Apply the temporary pod
                            kubectl apply -f file-copy-pod.yaml

                            # Wait for pod to be ready
                            kubectl wait --for=condition=Ready pod/file-copy-pod-${env.TENANT_NAME} -n ${env.K8S_NAMESPACE} --timeout=60s

                            echo "Temporary pod is ready, copying files..."
                        """
                    }
                }
            }
        }

        stage('Copy Font Files') {
            steps {
                script {
                    withCredentials([file(credentialsId: 'KUBECONFIG_PATH', variable: 'KCFG')]) {
                        sh """
                            export KUBECONFIG="\$KCFG"

                            # Create dummy font directory structure for demonstration
                            mkdir -p temp-uploads/font
                            echo "Font files would be copied here" > temp-uploads/font/README.txt

                            echo "Copying font files..."
                            kubectl exec file-copy-pod-${env.TENANT_NAME} -n ${env.K8S_NAMESPACE} -- mkdir -p /uploads/font
                            kubectl cp temp-uploads/font/. ${env.K8S_NAMESPACE}/file-copy-pod-${env.TENANT_NAME}:/uploads/font/
                            echo "Font files copied successfully"
                        """
                    }
                }
            }
        }

        stage('Copy Photo Files') {
            steps {
                script {
                    withCredentials([file(credentialsId: 'KUBECONFIG_PATH', variable: 'KCFG')]) {
                        sh """
                            export KUBECONFIG="\$KCFG"

                            # Check if source directory exists
                            echo "=== CHECKING SOURCE DIRECTORY ==="
                            if [ -d "inventory/uploads/photos" ]; then
                                echo "âœ… Source directory exists: inventory/uploads/photos"
                                echo "ðŸ“ Contents of inventory/uploads/photos:"
                                ls -la inventory/uploads/photos/ || echo "Directory is empty or not accessible"
                                echo "ðŸ“Š File count: \$(find inventory/uploads/photos -type f | wc -l)"
                                
                                echo "=== COPYING PHOTO FILES ==="
                                kubectl exec file-copy-pod-${env.TENANT_NAME} -n ${env.K8S_NAMESPACE} -- mkdir -p /uploads/photos
                                kubectl cp inventory/uploads/photos/. ${env.K8S_NAMESPACE}/file-copy-pod-${env.TENANT_NAME}:/uploads/photos/
                                
                                echo "=== VERIFYING COPY OPERATION ==="
                                echo "ðŸ“ Contents in PVC after copy:"
                                kubectl exec file-copy-pod-${env.TENANT_NAME} -n ${env.K8S_NAMESPACE} -- ls -la /uploads/photos/
                                echo "ðŸ“Š File count in PVC: \$(kubectl exec file-copy-pod-${env.TENANT_NAME} -n ${env.K8S_NAMESPACE} -- find /uploads/photos -type f | wc -l)"
                                
                                echo "âœ… Photo files copied and verified successfully"
                            else
                                echo "âš ï¸  Source directory not found: inventory/uploads/photos"
                                echo "ðŸ“ Available directories in inventory/uploads:"
                                ls -la inventory/uploads/ || echo "inventory/uploads directory does not exist"
                                
                                # Create dummy photo directory for demonstration
                                echo "ðŸ“ Creating dummy photo files for demonstration..."
                                mkdir -p temp-uploads/photos
                                echo "Sample photo file 1" > temp-uploads/photos/sample1.jpg
                                echo "Sample photo file 2" > temp-uploads/photos/sample2.png
                                
                                kubectl exec file-copy-pod-${env.TENANT_NAME} -n ${env.K8S_NAMESPACE} -- mkdir -p /uploads/photos
                                kubectl cp temp-uploads/photos/. ${env.K8S_NAMESPACE}/file-copy-pod-${env.TENANT_NAME}:/uploads/photos/
                                
                                echo "=== VERIFYING DUMMY COPY OPERATION ==="
                                kubectl exec file-copy-pod-${env.TENANT_NAME} -n ${env.K8S_NAMESPACE} -- ls -la /uploads/photos/
                                echo "âœ… Dummy photo files created and copied successfully"
                            fi
                        """
                    }
                }
            }
        }

        stage('Copy Global User Files') {
            steps {
                script {
                    withCredentials([file(credentialsId: 'KUBECONFIG_PATH', variable: 'KCFG')]) {
                        sh """
                            export KUBECONFIG="\$KCFG"

                            # Create dummy globaluserfiles directory structure for demonstration
                            mkdir -p temp-uploads/globaluserfiles
                            echo "Global user files would be copied here" > temp-uploads/globaluserfiles/README.txt

                            echo "Copying global user files..."
                            kubectl exec file-copy-pod-${env.TENANT_NAME} -n ${env.K8S_NAMESPACE} -- mkdir -p /uploads/globaluserfiles
                            kubectl cp temp-uploads/globaluserfiles/. ${env.K8S_NAMESPACE}/file-copy-pod-${env.TENANT_NAME}:/uploads/globaluserfiles/
                            echo "Global user files copied successfully"
                        """
                    }
                }
            }
        }

        stage('Cleanup File Copy Pod') {
            steps {
                script {
                    withCredentials([file(credentialsId: 'KUBECONFIG_PATH', variable: 'KCFG')]) {
                        sh """
                            export KUBECONFIG="\$KCFG"

                            echo "=========================================="
                            echo "FINAL PVC VERIFICATION"
                            echo "=========================================="
                            
                            # Verify the files are in the PVC
                            echo "ðŸ“ Root uploads directory contents:"
                            kubectl exec file-copy-pod-${env.TENANT_NAME} -n ${env.K8S_NAMESPACE} -- ls -la /uploads/

                            # Show directory structure
                            echo "ðŸ“‚ Complete directory structure in PVC:"
                            kubectl exec file-copy-pod-${env.TENANT_NAME} -n ${env.K8S_NAMESPACE} -- find /uploads -type d || true

                            # Show all files with sizes
                            echo "ðŸ“„ All files in PVC with sizes:"
                            kubectl exec file-copy-pod-${env.TENANT_NAME} -n ${env.K8S_NAMESPACE} -- find /uploads -type f -exec ls -lh {} \\; || true

                            # Count files by directory
                            echo "ðŸ“Š File counts by directory:"
                            kubectl exec file-copy-pod-${env.TENANT_NAME} -n ${env.K8S_NAMESPACE} -- sh -c '
                                for dir in /uploads/*/; do
                                    if [ -d "\$dir" ]; then
                                        count=\$(find "\$dir" -type f | wc -l)
                                        echo "  \$(basename "\$dir"): \$count files"
                                    fi
                                done
                            ' || true

                            # Test PVC mount by creating a test file
                            echo "ðŸ§ª Testing PVC write access:"
                            kubectl exec file-copy-pod-${env.TENANT_NAME} -n ${env.K8S_NAMESPACE} -- sh -c 'echo "PVC test file created at \$(date)" > /uploads/pvc-test.txt'
                            kubectl exec file-copy-pod-${env.TENANT_NAME} -n ${env.K8S_NAMESPACE} -- cat /uploads/pvc-test.txt

                            echo "=========================================="
                            echo "PVC VERIFICATION COMPLETE"
                            echo "=========================================="

                            # Clean up the temporary pod
                            echo "ðŸ§¹ Cleaning up temporary pod..."
                            kubectl delete pod file-copy-pod-${env.TENANT_NAME} -n ${env.K8S_NAMESPACE}

                            echo "âœ… File copy operation completed and temporary pod cleaned up"
                        """

                        // Clean up temporary manifest and directories
                        sh 'rm -f file-copy-pod.yaml'
                        sh 'rm -rf temp-uploads'
                    }
                }
            }
        }

        stage('LB: Discover IDs') {
            steps {
                withCredentials([ file(credentialsId: 'KUBECONFIG_PATH', variable: 'KCFG') ]) {
                    script {
                        // Get LoadBalancer ID
                        env.LB_ID = sh(
                            script: "export KUBECONFIG='${KCFG}'; kubectl get svc inventory-${env.TENANT_NAME}-service -n ${env.K8S_NAMESPACE} -o jsonpath='{.metadata.annotations.kubernetes\\.digitalocean\\.com/load-balancer-id}'",
                            returnStdout: true
                        ).trim()
                        if (!env.LB_ID) { error "LB_ID not found on service annotation" }

                        // Wait for external IP to be assigned (with timeout)
                        echo "Waiting for LoadBalancer external IP to be assigned..."
                        def maxAttempts = 60  // 10 minutes max wait
                        def attempt = 0

                        while (attempt < maxAttempts) {
                            env.EXTERNAL_IP = sh(
                                script: "export KUBECONFIG='${KCFG}'; kubectl get svc inventory-${env.TENANT_NAME}-service -n ${env.K8S_NAMESPACE} -o jsonpath='{.status.loadBalancer.ingress[0].ip}'",
                                returnStdout: true
                            ).trim()

                            if (env.EXTERNAL_IP && env.EXTERNAL_IP != 'null' && env.EXTERNAL_IP != '') {
                                echo "External IP assigned: ${env.EXTERNAL_IP}"
                                break
                            }

                            attempt++
                            echo "Attempt ${attempt}/${maxAttempts}: External IP not ready yet, waiting 10 seconds..."
                            sleep(10)
                        }

                        if (!env.EXTERNAL_IP || env.EXTERNAL_IP == 'null' || env.EXTERNAL_IP == '') {
                            error "External IP not assigned after ${maxAttempts} attempts (${maxAttempts * 10} seconds)"
                        }

                        echo "Found LB_ID: ${env.LB_ID}"
                        echo "Service IP : ${env.EXTERNAL_IP}"
                    }
                }
            }
        }

        stage('DNS: Ensure domain exists') {
            steps {
                withCredentials([ string(credentialsId: 'DO_API_TOKEN', variable: 'DO_API_TOKEN') ]) {
                    script {
                        echo "Checking if domain ${env.DO_DOMAIN} exists in DigitalOcean..."

                        // Check if domain exists
                        def domainExists = sh(
                            script: 'curl -sS -H "Authorization: Bearer $DO_API_TOKEN" "https://api.digitalocean.com/v2/domains/' + env.DO_DOMAIN + '" | jq -r ".domain.name // empty"',
                            returnStdout: true
                        ).trim()

                        if (domainExists == env.DO_DOMAIN) {
                            echo "Domain ${env.DO_DOMAIN} already exists in DigitalOcean"
                        } else {
                            echo "Domain ${env.DO_DOMAIN} not found, creating it..."

                            def createResult = sh(
                                script: 'curl -sS -X POST -H "Content-Type: application/json" -H "Authorization: Bearer $DO_API_TOKEN" -d \'{"name":"' + env.DO_DOMAIN + '"}\' "https://api.digitalocean.com/v2/domains"',
                                returnStdout: true
                            ).trim()

                            // Check if creation was successful
                            def createdDomain = sh(
                                script: 'echo \'' + createResult + '\' | jq -r ".domain.name // empty"',
                                returnStdout: true
                            ).trim()

                            if (createdDomain == env.DO_DOMAIN) {
                                echo "Successfully created domain ${env.DO_DOMAIN} in DigitalOcean"
                                echo "Default DNS records created for the domain"
                            } else {
                                echo "Domain creation response: ${createResult}"
                                error "Failed to create domain ${env.DO_DOMAIN} in DigitalOcean"
                            }
                        }
                    }
                }
            }
        }

        stage('DNS: Ensure A record') {
            steps {
                withCredentials([ string(credentialsId: 'DO_API_TOKEN', variable: 'DO_API_TOKEN') ]) {
                    script {
                        // Get existing DNS records
                        def listRecords = sh(
                            script: 'curl -sS -H "Authorization: Bearer $DO_API_TOKEN" "https://api.digitalocean.com/v2/domains/' + env.DO_DOMAIN + '/records"',
                            returnStdout: true
                        ).trim()

                        // Check if A record already exists for this tenant
                        def existingRecordId = sh(
                            script: 'echo \'' + listRecords + '\' | jq -r --arg name "' + env.TENANT_NAME + '" \'(.domain_records // []) | map(select(.type=="A" and .name==$name)) | (.[0].id // empty)\'',
                            returnStdout: true
                        ).trim()

                        if (existingRecordId && existingRecordId != '' && existingRecordId != 'null') {
                            echo "Found existing A record with ID: ${existingRecordId}"

                            // Get current IP of existing record
                            def currentIp = sh(
                                script: 'echo \'' + listRecords + '\' | jq -r --arg id "' + existingRecordId + '" \'(.domain_records // []) | map(select((.id|tostring)==$id)) | (.[0].data // "")\'',
                                returnStdout: true
                            ).trim()

                            if (currentIp != env.EXTERNAL_IP) {
                                echo "Updating A record from ${currentIp} to ${env.EXTERNAL_IP}"
                                sh 'curl -sS -X PUT -H "Content-Type: application/json" -H "Authorization: Bearer $DO_API_TOKEN" -d \'{"data":"' + env.EXTERNAL_IP + '"}\' "https://api.digitalocean.com/v2/domains/' + env.DO_DOMAIN + '/records/' + existingRecordId + '"'
                            } else {
                                echo "A record already points to correct IP: ${env.EXTERNAL_IP}"
                            }
                        } else {
                            echo "Creating new A record for ${env.TENANT_NAME}.${env.DO_DOMAIN} -> ${env.EXTERNAL_IP}"
                            sh 'curl -sS -X POST -H "Content-Type: application/json" -H "Authorization: Bearer $DO_API_TOKEN" -d \'{"type":"A","name":"' + env.TENANT_NAME + '","data":"' + env.EXTERNAL_IP + '","ttl":60}\' "https://api.digitalocean.com/v2/domains/' + env.DO_DOMAIN + '/records"'
                        }

                        echo "DNS A record operation completed"
                    }
                }
            }
        }

        stage('DNS: Wait for resolution') {
            steps {
                script {
                    withEnv([
                        "FQDN=${env.TENANT_NAME}.${env.DO_DOMAIN}",
                        "IP=${env.EXTERNAL_IP}"
                    ]) {
                        sh '''#!/bin/bash
                            set -euo pipefail
                            FQDN="$FQDN"
                            IP="$IP"

                            resolve() {
                                if command -v dig >/dev/null 2>&1; then
                                    dig +short A "$FQDN" | sed '/^$/d' | sort -u
                                else
                                    getent ahostsv4 "$FQDN" 2>/dev/null | awk '{print $1}' | sort -u
                                fi
                            }

                            for i in $(seq 1 60); do
                                RES="$(resolve || true)"
                                echo "Resolved for $FQDN: $RES"
                                if printf '%s\n' "$RES" | grep -Fx "$IP" >/dev/null; then
                                    echo "DNS OK: $FQDN -> $IP"
                                    exit 0
                                fi
                                sleep 5
                            done

                            echo "DNS not pointing yet to $IP for $FQDN"
                            exit 1
                        '''
                    }
                }
            }
        }

        stage('Cert: Ensure managed cert') {
            steps {
                withCredentials([ string(credentialsId: 'DO_API_TOKEN', variable: 'DO_API_TOKEN') ]) {
                    script {
                        def fqdn = "${env.TENANT_NAME}.${env.DO_DOMAIN}"
                        echo "Ensuring DO managed cert for: ${fqdn}"

                        // Get existing certificates
                        def certsJson = sh(
                            script: 'curl -sS -H "Authorization: Bearer $DO_API_TOKEN" "https://api.digitalocean.com/v2/certificates"',
                            returnStdout: true
                        ).trim()

                        // Check for existing certificate for this FQDN
                        def existingCertId = sh(
                            script: 'echo \'' + certsJson + '\' | jq -r --arg fq "' + fqdn + '" \'(.certificates // []) | map(select((.dns_names // []) | index($fq))) | (.[0].id // empty)\'',
                            returnStdout: true
                        ).trim()

                        if (!existingCertId || existingCertId == '' || existingCertId == 'null') {
                            // Check for wildcard certificate
                            def wildcardDomain = "*." + env.DO_DOMAIN
                            existingCertId = sh(
                                script: 'echo \'' + certsJson + '\' | jq -r --arg wc "' + wildcardDomain + '" \'(.certificates // []) | map(select((.dns_names // []) | index($wc))) | (.[0].id // empty)\'',
                                returnStdout: true
                            ).trim()
                        }

                        if (existingCertId && existingCertId != '' && existingCertId != 'null') {
                            echo "Found existing certificate with ID: ${existingCertId}"
                            env.CERT_ID = existingCertId
                        } else {
                            echo "No existing certificate found, creating new Let's Encrypt certificate for ${fqdn}"

                            // Create new certificate
                            def createResult = sh(
                                script: 'curl -sS -X POST -H "Content-Type: application/json" -H "Authorization: Bearer $DO_API_TOKEN" -d \'{"name":"' + fqdn + '","type":"lets_encrypt","dns_names":["' + fqdn + '"]}\' "https://api.digitalocean.com/v2/certificates"',
                                returnStdout: true
                            ).trim()

                            // Extract certificate ID from creation response
                            def newCertId = sh(
                                script: 'echo \'' + createResult + '\' | jq -r \'.certificate.id // .id // empty\'',
                                returnStdout: true
                            ).trim()

                            if (newCertId && newCertId != '' && newCertId != 'null') {
                                echo "Certificate creation initiated with ID: ${newCertId}"

                                // Wait for certificate to be issued (max 6 minutes)
                                def maxAttempts = 36
                                def attempt = 0
                                def certState = 'unknown'

                                while (attempt < maxAttempts) {
                                    sleep(10)
                                    attempt++

                                    def stateResult = sh(
                                        script: 'curl -sS -H "Authorization: Bearer $DO_API_TOKEN" "https://api.digitalocean.com/v2/certificates/' + newCertId + '"',
                                        returnStdout: true
                                    ).trim()

                                    certState = sh(
                                        script: 'echo \'' + stateResult + '\' | jq -r \'.certificate.state // .state // "unknown"\'',
                                        returnStdout: true
                                    ).trim()

                                    echo "Certificate state check ${attempt}/${maxAttempts}: ${certState}"

                                    if (certState == 'verified') {
                                        echo "Certificate successfully issued!"
                                        env.CERT_ID = newCertId
                                        break
                                    } else if (certState == 'error') {
                                        echo "Certificate issuance failed"
                                        break
                                    }
                                }

                                if (certState != 'verified') {
                                    error "Certificate failed to be issued after ${maxAttempts} attempts (6 minutes). State: ${certState}"
                                }
                            } else {
                                echo "Certificate creation response: ${createResult}"
                                error "Failed to create certificate for ${fqdn}"
                            }
                        }

                        if (!env.CERT_ID) {
                            error "Could not find or issue a DigitalOcean certificate for ${fqdn}"
                        }

                        echo "Using certificate ID: ${env.CERT_ID}"
                    }
                }
            }
        }

        stage('Service: Attach cert & redirect') {
            steps {
                withCredentials([ file(credentialsId: 'KUBECONFIG_PATH', variable: 'KCFG') ]) {
                    script {
                        withEnv([
                            "TENANT=${env.TENANT_NAME}",
                            "KNS=${env.K8S_NAMESPACE}"
                        ]) {
                            sh '''
                                export KUBECONFIG="$KCFG"

                                # First, disable TLS passthrough
                                echo "Disabling TLS passthrough..."
                                kubectl annotate svc inventory-"$TENANT"-service \
                                    -n "$KNS" \
                                    service.beta.kubernetes.io/do-loadbalancer-tls-passthrough="false" \
                                    --overwrite

                                # Wait a moment for the change to process
                                sleep 5

                                # Now attach the certificate
                                echo "Attaching certificate..."
                                kubectl annotate svc inventory-"$TENANT"-service \
                                    -n "$KNS" \
                                    service.beta.kubernetes.io/do-loadbalancer-certificate-id="${CERT_ID}" \
                                    --overwrite

                                # Configure TLS ports
                                echo "Configuring TLS ports..."
                                kubectl annotate svc inventory-"$TENANT"-service \
                                    -n "$KNS" \
                                    service.beta.kubernetes.io/do-loadbalancer-tls-ports="443" \
                                    --overwrite

                                # Finally, enable HTTPS redirect
                                echo "Enabling HTTPS redirect..."
                                kubectl annotate svc inventory-"$TENANT"-service \
                                    -n "$KNS" \
                                    service.beta.kubernetes.io/do-loadbalancer-redirect-http-to-https="true" \
                                    --overwrite
                            '''
                        }
                        echo "Certificate attached and HTTPS redirect enabled."
                    }
                }
            }
        }

        stage('Final Deployment Summary') {
            steps {
                script {
                    echo "=========================================="
                    echo "DEPLOYMENT SUMMARY"
                    echo "=========================================="
                    echo ""
                    echo "âœ… DEPLOYMENT DETAILS:"
                    echo "  Tenant Name: ${env.TENANT_NAME}"
                    echo "  Application: ${env.APP_NAME}"
                    echo "  Docker Image: ${env.DOCKER_IMAGE}"
                    echo "  Kubernetes Namespace: ${env.K8S_NAMESPACE}"
                    echo "  Environment: ${env.ENVIRONMENT_NAME}"
                    echo ""
                    echo "ðŸŒ NETWORK DETAILS:"
                    echo "  Domain: ${env.DO_DOMAIN}"
                    echo "  FQDN: ${env.TENANT_NAME}.${env.DO_DOMAIN}"
                    echo "  External IP: ${env.EXTERNAL_IP}"
                    echo "  Load Balancer ID: ${env.LB_ID}"
                    echo "  Certificate ID: ${env.CERT_ID}"
                    echo ""
                    echo "ðŸ”— ACCESS URLs:"
                    echo "  HTTP: http://${env.TENANT_NAME}.${env.DO_DOMAIN}"
                    echo "  HTTPS: https://${env.TENANT_NAME}.${env.DO_DOMAIN}"
                    echo ""
                    echo "=========================================="
                    echo "DEPLOYMENT COMPLETED SUCCESSFULLY"
                    echo "=========================================="
                }
            }
        }
    }

    post {
        success {
            echo "Deployment completed successfully for tenant: ${env.TENANT_NAME}"
            echo "Application is accessible at: https://${env.TENANT_NAME}.${env.DO_DOMAIN}"
            echo "Docker image deployed: ${env.DOCKER_IMAGE}"
            echo "Kubernetes namespace: ${env.K8S_NAMESPACE}"
        }
        failure {
            echo "Deployment failed for tenant: ${env.TENANT_NAME}"
            script {
                if (env.DOCKER_IMAGE) {
                    echo "Failed Docker image: ${env.DOCKER_IMAGE}"
                }
                if (env.K8S_NAMESPACE) {
                    echo "Target namespace: ${env.K8S_NAMESPACE}"
                }
            }
        }
        always {
            // Clean up temporary files
            sh 'rm -f k8s-deployment.yaml file-copy-pod.yaml build-artifacts.properties'
            sh 'rm -rf temp-uploads'
        }
    }
}