pipeline {
    agent any

    tools {
        maven 'maven3'
    }

    parameters {
        // Build parameters
        string(name: 'BRANCH', defaultValue: 'test1', description: 'Branch to build from')
        string(name: 'TENANT_NAME', defaultValue: '', description: 'Tenant name for deployment')
        string(name: 'APP_NAME', defaultValue: 'inventory', description: 'Application name')
        string(name: 'SUBSCRIPTION_TIER', defaultValue: 'BASIC', description: 'Subscription tier')
        string(name: 'BILLING_EMAIL', defaultValue: '', description: 'Billing email address')
        string(name: 'K8S_NAMESPACE', defaultValue: '', description: 'Kubernetes namespace (auto-generated if empty)')
        
        // DigitalOcean parameters
        string(name: 'DO_LOADBALANCER_ID', defaultValue: '', description: 'DigitalOcean Load Balancer ID for Kubernetes Service annotation')
        
        // Docker parameters
        string(name: 'DOCKER_USER', defaultValue: 'techvvsadmin', description: 'Docker Hub username')
        
                 // Application configuration parameters
         string(name: 'ENVIRONMENT_NAME', defaultValue: 'prod', description: 'Environment name (prod, dev1)')
         string(name: 'LOAD_REF_DATA', defaultValue: 'no', description: 'Load reference data (yes/no)')
         string(name: 'TAX_PERCENTAGE', defaultValue: '0', description: 'Tax percentage')
         string(name: 'MAX_FILE_SIZE', defaultValue: '500MB', description: 'Maximum file size')
        string(name: 'MAX_REQ_SIZE', defaultValue: '500MB', description: 'Maximum request size')
        
        // Database configuration
        string(name: 'DB_DRIVER_CLASS_NAME', defaultValue: 'org.postgresql.Driver', description: 'Database driver class')
        string(name: 'DB_JPA_DATABASE_PLATFORM', defaultValue: 'org.hibernate.dialect.PostgreSQLDialect', description: 'JPA database platform')
        string(name: 'DB_JPA_HIBERNATE_DIALECT', defaultValue: 'org.hibernate.dialect.PostgreSQLDialect', description: 'Hibernate dialect')
        string(name: 'DB_USERNAME', defaultValue: 'doadmin', description: 'Database username')
        string(name: 'SANDBOX_POSTGRESQL_URI', defaultValue: 'jdbc:postgresql://private-sandbox-cluster-do-user-1326368-0.e.db.ondigitalocean.com:25060', description: 'Database uri')
        string(name: 'DB_URI', defaultValue: 'jdbc:postgresql://private-sandbox-cluster-do-user-1326368-0.e.db.ondigitalocean.com:25060', description: 'Database uri')
        string(name: 'SPRING_DATABASE_ACTION', defaultValue: 'update', description: 'Database action (update, create-drop)')
        string(name: 'DB_H2_CONSOLE_ENABLED', defaultValue: 'false', description: 'Enable H2 console')
        string(name: 'DB_H2_WEB_ALLOWOTHERS', defaultValue: 'false', description: 'Allow others to access H2 console')
        
        // PayPal configuration
        string(name: 'PAYPAL_ENVIRONMENT', defaultValue: 'SANDBOX', description: 'PayPal environment (SANDBOX/PRODUCTION)')
        string(name: 'PAYPAL_BRAND_NAME', defaultValue: 'techvvs_clothing_app_1', description: 'PayPal brand name')
        
        // Wallet configuration
        string(name: 'WALLET_BRAND', defaultValue: 'Tulip', description: 'Wallet brand organization name')
        string(name: 'WALLET_BRAND_PROGRAM', defaultValue: 'Tulip Membership', description: 'Wallet brand program name')
        string(name: 'WALLET_GOOGLE_SERVICE_ACC_KEY_PATH', defaultValue: 'classpath:/uploads/applecert/', description: 'Google service account key path')
        string(name: 'WALLET_GOOGLE_ISSUER_ID', defaultValue: '', description: 'Google wallet issuer ID')
        string(name: 'WALLET_GOOGLE_CLASS_ID', defaultValue: '', description: 'Google wallet class ID')
        
                 // METRC configuration
         string(name: 'METRC_MCP_FILE_PATH', defaultValue: 'classpath:/uploads/mcp/metrc-mcp-connector.dxt', description: 'METRC MCP file path')
        
        // Request logging configuration
        string(name: 'REQUEST_LOGGING_ENABLED', defaultValue: 'true', description: 'Enable request logging')
        string(name: 'REQUEST_LOGGING_HEADERS', defaultValue: 'true', description: 'Log request headers')
        string(name: 'REQUEST_LOGGING_DEVICE_INFO', defaultValue: 'true', description: 'Log device info')
        string(name: 'REQUEST_LOGGING_SESSION_INFO', defaultValue: 'true', description: 'Log session info')
        string(name: 'REQUEST_LOGGING_SECURITY_INFO', defaultValue: 'false', description: 'Log security info')
    }

    stages {
        stage('Checkout') {
            steps {
                checkout([
                    $class: 'GitSCM',
                    branches: [[name: "*/${params.BRANCH}"]],
                    userRemoteConfigs: [[url: 'https://github.com/javascriptjenkins/inventory.git', credentialsId: 'githubcreds']]
                ])
            }
        }



        stage('Log Build Parameters') {
            steps {
                script {
                    echo "=========================================="
                    echo "JENKINS BUILD PARAMETERS LOG"
                    echo "=========================================="
                    echo ""
                    
                    echo "üìã BUILD PARAMETERS:"
                    echo "  BRANCH: ${params.BRANCH}"
                    echo "  TENANT_NAME: ${params.TENANT_NAME}"
                    echo "  APP_NAME: ${params.APP_NAME}"
                    echo "  SUBSCRIPTION_TIER: ${params.SUBSCRIPTION_TIER}"
                    echo "  BILLING_EMAIL: ${params.BILLING_EMAIL}"
                    echo "  K8S_NAMESPACE: ${params.K8S_NAMESPACE}"
                    echo ""
                    
                    echo "üåê DIGITALOCEAN PARAMETERS:"
                    echo "  DO_LOADBALANCER_ID: ${params.DO_LOADBALANCER_ID}"
                    echo ""
                    
                    echo "üê≥ DOCKER PARAMETERS:"
                    echo "  DOCKER_USER: ${params.DOCKER_USER}"
                    echo ""
                    
                    echo "‚öôÔ∏è APPLICATION CONFIGURATION:"
                    echo "  ENVIRONMENT_NAME: ${params.ENVIRONMENT_NAME}"
                    echo "  LOAD_REF_DATA: ${params.LOAD_REF_DATA}"
                    echo "  TAX_PERCENTAGE: ${params.TAX_PERCENTAGE}"
                    echo "  MAX_FILE_SIZE: ${params.MAX_FILE_SIZE}"
                    echo "  MAX_REQ_SIZE: ${params.MAX_REQ_SIZE}"
                    echo ""
                    
                    echo "üóÑÔ∏è DATABASE CONFIGURATION:"
                    echo "  DB_DRIVER_CLASS_NAME: ${params.DB_DRIVER_CLASS_NAME}"
                    echo "  DB_JPA_DATABASE_PLATFORM: ${params.DB_JPA_DATABASE_PLATFORM}"
                    echo "  DB_JPA_HIBERNATE_DIALECT: ${params.DB_JPA_HIBERNATE_DIALECT}"
                    echo "  DB_USERNAME: ${params.DB_USERNAME}"
                    echo "  SANDBOX_POSTGRESQL_URI: ${params.SANDBOX_POSTGRESQL_URI}"
                    echo "  env.DB_URI: ${env.DB_URI}"
                    echo "  SPRING_DATABASE_ACTION: ${params.SPRING_DATABASE_ACTION}"
                    echo "  DB_H2_CONSOLE_ENABLED: ${params.DB_H2_CONSOLE_ENABLED}"
                    echo "  DB_H2_WEB_ALLOWOTHERS: ${params.DB_H2_WEB_ALLOWOTHERS}"
                    echo ""
                    
                    echo "üí≥ PAYPAL CONFIGURATION:"
                    echo "  PAYPAL_ENVIRONMENT: ${params.PAYPAL_ENVIRONMENT}"
                    echo "  PAYPAL_BRAND_NAME: ${params.PAYPAL_BRAND_NAME}"
                    echo ""
                    
                    echo "üëõ WALLET CONFIGURATION:"
                    echo "  WALLET_BRAND: ${params.WALLET_BRAND}"
                    echo "  WALLET_BRAND_PROGRAM: ${params.WALLET_BRAND_PROGRAM}"
                    echo "  WALLET_GOOGLE_SERVICE_ACC_KEY_PATH: ${params.WALLET_GOOGLE_SERVICE_ACC_KEY_PATH}"
                    echo "  WALLET_GOOGLE_ISSUER_ID: ${params.WALLET_GOOGLE_ISSUER_ID}"
                    echo "  WALLET_GOOGLE_CLASS_ID: ${params.WALLET_GOOGLE_CLASS_ID}"
                    echo ""
                    
                    echo "üåø METRC CONFIGURATION:"
                    echo "  METRC_MCP_FILE_PATH: ${params.METRC_MCP_FILE_PATH}"
                    echo ""
                    
                    echo "üìä REQUEST LOGGING CONFIGURATION:"
                    echo "  REQUEST_LOGGING_ENABLED: ${params.REQUEST_LOGGING_ENABLED}"
                    echo "  REQUEST_LOGGING_HEADERS: ${params.REQUEST_LOGGING_HEADERS}"
                    echo "  REQUEST_LOGGING_DEVICE_INFO: ${params.REQUEST_LOGGING_DEVICE_INFO}"
                    echo "  REQUEST_LOGGING_SESSION_INFO: ${params.REQUEST_LOGGING_SESSION_INFO}"
                    echo "  REQUEST_LOGGING_SECURITY_INFO: ${params.REQUEST_LOGGING_SECURITY_INFO}"
                    echo ""
                    
                    echo "=========================================="
                    echo "END OF BUILD PARAMETERS LOG"
                    echo "=========================================="
                }
            }
        }

        stage('Update Application Properties') {
            steps {
                script {
                    withCredentials([
                        // API Keys and Secrets
                        string(credentialsId: 'TWILIO_API_USER', variable: 'TWILIO_API_USER'),
                        string(credentialsId: 'TWILIO_API_PASSWORD', variable: 'TWILIO_API_PASSWORD'),
                        string(credentialsId: 'SENDGRID_API_KEY', variable: 'SENDGRID_API_KEY'),
                        string(credentialsId: 'JWT_SECRET_KEY', variable: 'JWT_SECRET_KEY'),
                        string(credentialsId: 'METRC_API_KEY_USERNAME', variable: 'METRC_API_KEY_USERNAME'),
                        string(credentialsId: 'METRC_API_KEY_PASSWORD', variable: 'METRC_API_KEY_PASSWORD'),
                        string(credentialsId: 'PAYPAL_CLIENT_ID', variable: 'PAYPAL_CLIENT_ID'),
                        string(credentialsId: 'PAYPAL_CLIENT_SECRET', variable: 'PAYPAL_CLIENT_SECRET'),
                        string(credentialsId: 'ANTHROPIC_API_KEY', variable: 'ANTHROPIC_API_KEY'),
                        
                        // Database credentials
                        string(credentialsId: 'DB_PASSWORD', variable: 'DB_PASSWORD'),
                        string(credentialsId: 'POSTGRE_TEST_DB_PASSWORD', variable: 'POSTGRE_TEST_DB_PASSWORD'),
                        string(credentialsId: 'POSTGRE_PROD_DB_PASSWORD', variable: 'POSTGRE_PROD_DB_PASSWORD'),
                        string(credentialsId: 'POSTGRE_ALPHA_DB_PASSWORD', variable: 'POSTGRE_ALPHA_DB_PASSWORD'),
                        
                        // Digital Ocean credentials
                        string(credentialsId: 'DO_API_TOKEN', variable: 'DO_API_TOKEN'),
                        string(credentialsId: 'DO_DOMAIN', variable: 'DO_DOMAIN'),
                        string(credentialsId: 'DO_LB_IP', variable: 'DO_LB_IP'),
                        string(credentialsId: 'SANDBOX_POSTGRESQL_PUBLIC_USER', variable: 'SANDBOX_POSTGRESQL_PUBLIC_USER'),
                        string(credentialsId: 'SANDBOX_POSTGRESQL_PUBLIC_URI', variable: 'SANDBOX_POSTGRESQL_PUBLIC_URI'),
                        string(credentialsId: 'SANDBOX_POSTGRESQL_PASSWORD', variable: 'SANDBOX_POSTGRESQL_PASSWORD'),
                        
                        // Jenkins credentials
                        string(credentialsId: 'JENKINS_USERNAME', variable: 'JENKINS_USERNAME'),
                        string(credentialsId: 'JENKINS_API_TOKEN', variable: 'JENKINS_API_TOKEN'),

                        // Kubernetes config file
                        file(credentialsId: 'KUBECONFIG_PATH', variable: 'KUBECONFIG_FILE')
                    ]) {
                        // Log credentials being used (without exposing actual values)
                        echo "=========================================="
                        echo "CREDENTIALS BEING USED (IDs only for security)"
                        echo "=========================================="
                        echo ""
                        
                        echo "üîê API KEYS AND SECRETS:"
                        echo "  TWILIO_API_USER: [CREDENTIAL ID: TWILIO_API_USER]"
                        echo "  TWILIO_API_PASSWORD: [CREDENTIAL ID: TWILIO_API_PASSWORD]"
                        echo "  SENDGRID_API_KEY: [CREDENTIAL ID: SENDGRID_API_KEY]"
                        echo "  JWT_SECRET_KEY: [CREDENTIAL ID: JWT_SECRET_KEY]"
                        echo "  METRC_API_KEY_USERNAME: [CREDENTIAL ID: METRC_API_KEY_USERNAME]"
                        echo "  METRC_API_KEY_PASSWORD: [CREDENTIAL ID: METRC_API_KEY_PASSWORD]"
                        echo "  PAYPAL_CLIENT_ID: [CREDENTIAL ID: PAYPAL_CLIENT_ID]"
                        echo "  PAYPAL_CLIENT_SECRET: [CREDENTIAL ID: PAYPAL_CLIENT_SECRET]"
                        echo "  ANTHROPIC_API_KEY: [CREDENTIAL ID: ANTHROPIC_API_KEY]"
                        echo ""
                        
                        echo "üóÑÔ∏è DATABASE CREDENTIALS:"
                        echo "  DB_PASSWORD: [CREDENTIAL ID: DB_PASSWORD]"
                        echo "  POSTGRE_TEST_DB_PASSWORD: [CREDENTIAL ID: POSTGRE_TEST_DB_PASSWORD]"
                        echo "  POSTGRE_PROD_DB_PASSWORD: [CREDENTIAL ID: POSTGRE_PROD_DB_PASSWORD]"
                        echo "  POSTGRE_ALPHA_DB_PASSWORD: [CREDENTIAL ID: POSTGRE_ALPHA_DB_PASSWORD]"
                        echo "  SANDBOX_POSTGRESQL_PUBLIC_USER: [CREDENTIAL ID: SANDBOX_POSTGRESQL_PUBLIC_USER]"
                        echo "  SANDBOX_POSTGRESQL_PUBLIC_URI: [CREDENTIAL ID: SANDBOX_POSTGRESQL_PUBLIC_URI]"
                        echo "  SANDBOX_POSTGRESQL_PASSWORD: [CREDENTIAL ID: SANDBOX_POSTGRESQL_PASSWORD]"
                        echo ""
                        
                        echo "üåê DIGITALOCEAN CREDENTIALS:"
                        echo "  DO_API_TOKEN: [CREDENTIAL ID: DO_API_TOKEN]"
                        echo "  DO_DOMAIN: [CREDENTIAL ID: DO_DOMAIN]"
                        echo "  DO_LB_IP: [CREDENTIAL ID: DO_LB_IP]"
                        echo ""
                        
                        echo "üîß JENKINS CREDENTIALS:"
                        echo "  JENKINS_USERNAME: [CREDENTIAL ID: JENKINS_USERNAME]"
                        echo "  JENKINS_API_TOKEN: [CREDENTIAL ID: JENKINS_API_TOKEN]"
                        echo ""
                        
                        echo "‚ò∏Ô∏è KUBERNETES CONFIGURATION:"
                        echo "  KUBECONFIG_PATH: [CREDENTIAL ID: KUBECONFIG_PATH]"
                        echo ""
                        
                        echo "=========================================="
                        echo "END OF CREDENTIALS LOG"
                        echo "=========================================="
                        
                        dir('inventory') {
                            // Copy kubeconfig to a writable location and update the path in application.properties
               // Create kubeconfig from string content
         sh "mkdir -p kubeconfig"
         sh "cp ${KUBECONFIG_FILE} kubeconfig/tulip-sandbox-kubeconfig.yaml"
         sh "chmod 600 kubeconfig/tulip-sandbox-kubeconfig.yaml"


                             // Construct BASE_QR_DOMAIN from tenant name and DO domain
                             def baseQrDomain = "https://${params.TENANT_NAME}.${DO_DOMAIN}"
                             echo "Constructed BASE_QR_DOMAIN: ${baseQrDomain}"
                             
                             // Construct Kubernetes namespace from tenant name (same logic as Java code)
                             def k8sNamespace = params.K8S_NAMESPACE ?: "tenant-${params.TENANT_NAME.toLowerCase().replaceAll('[^a-z0-9-]', '-')}"
                             echo "Using Kubernetes namespace: ${k8sNamespace}"
                             
                             // Log all dynamic values being used
                             echo "=========================================="
                             echo "DYNAMIC VALUES CALCULATED DURING BUILD"
                             echo "=========================================="
                             echo ""
                             echo "üåê DYNAMIC DOMAIN CONFIGURATION:"
                             echo "  BASE_QR_DOMAIN: ${baseQrDomain}"
                             echo "  METRC_MCP_URI: ${baseQrDomain}/api/mcp"
                             echo ""
                             echo "‚ò∏Ô∏è KUBERNETES CONFIGURATION:"
                             echo "  K8S_NAMESPACE: ${k8sNamespace}"
                             echo ""
                             echo "=========================================="
                             echo "END OF DYNAMIC VALUES LOG"
                             echo "=========================================="
                             
                             // Update application.properties with all parameters
                             // Basic application settings
                             if (params.ENVIRONMENT_NAME) {
                                 sh "sed -i 's/^spring\\.profiles\\.active=.*/spring.profiles.active=${params.ENVIRONMENT_NAME}/' src/main/resources/application.properties"
                             }
                             if (params.LOAD_REF_DATA) {
                                 sh "sed -i 's/^load\\.ref\\.data=.*/load.ref.data=${params.LOAD_REF_DATA}/' src/main/resources/application.properties"
                             }
                             if (params.TAX_PERCENTAGE) {
                                 sh "sed -i 's/^tax\\.percentage=.*/tax.percentage=${params.TAX_PERCENTAGE}/' src/main/resources/application.properties"
                             }
                             sh "sed -i 's|^base\\.qr\\.domain=.*|base.qr.domain=${baseQrDomain}|' src/main/resources/application.properties"
                             if (params.MAX_FILE_SIZE) {
                                 sh "sed -i 's/^spring\\.servlet\\.multipart\\.max-file-size=.*/spring.servlet.multipart.max-file-size=${params.MAX_FILE_SIZE}/' src/main/resources/application.properties"
                             }
                             if (params.MAX_REQ_SIZE) {
                                 sh "sed -i 's/^spring\\.servlet\\.multipart\\.max-request-size=.*/spring.servlet.multipart.max-request-size=${params.MAX_REQ_SIZE}/' src/main/resources/application.properties"
                             }
                             
                             // Database settings
                             sh "sed -i 's|^spring\\.datasource\\.url=.*|spring.datasource.url=${params.DB_URI}/defaultdb?currentSchema=tenant_${params.TENANT_NAME}&sslmode=require|' src/main/resources/application.properties"
                             sh "echo 'Updated DB_URI: ${params.DB_URI}/defaultdb?currentSchema=tenant_${params.TENANT_NAME}&sslmode=require'"
                             if (params.DB_DRIVER_CLASS_NAME) {
                                 sh "sed -i 's/^spring\\.datasource\\.driver-class-name=.*/spring.datasource.driver-class-name=${params.DB_DRIVER_CLASS_NAME}/' src/main/resources/application.properties"
                             }
                             if (params.DB_JPA_DATABASE_PLATFORM) {
                                 sh "sed -i 's/^spring\\.jpa\\.database-platform=.*/spring.jpa.database-platform=${params.DB_JPA_DATABASE_PLATFORM}/' src/main/resources/application.properties"
                             }
                             if (params.DB_JPA_HIBERNATE_DIALECT) {
                                 sh "sed -i 's/^spring\\.jpa\\.properties\\.hibernate\\.dialect=.*/spring.jpa.properties.hibernate.dialect=${params.DB_JPA_HIBERNATE_DIALECT}/' src/main/resources/application.properties"
                             }
                            sh "sed -i 's/^spring\\.datasource\\.username=.*/spring.datasource.username=${SANDBOX_POSTGRESQL_PUBLIC_USER}/' src/main/resources/application.properties"
                            sh "sed -i 's/^spring\\.datasource\\.password=.*/spring.datasource.password=${SANDBOX_POSTGRESQL_PASSWORD}/' src/main/resources/application.properties"
                            sh "sed -i 's/^spring\\.jpa\\.properties\\.hibernate\\.default_schema=.*/spring.jpa.properties.hibernate.default_schema=${params.TENANT_NAME}/' src/main/resources/application.properties"

                             if (params.SPRING_DATABASE_ACTION) {
                                 sh "sed -i 's/^spring\\.jpa\\.hibernate\\.ddl-auto=.*/spring.jpa.hibernate.ddl-auto=${params.SPRING_DATABASE_ACTION}/' src/main/resources/application.properties"
                             }
                             if (params.DB_H2_CONSOLE_ENABLED) {
                                 sh "sed -i 's/^spring\\.h2\\.console\\.enabled=.*/spring.h2.console.enabled=${params.DB_H2_CONSOLE_ENABLED}/' src/main/resources/application.properties"
                             }
                             if (params.DB_H2_WEB_ALLOWOTHERS) {
                                 sh "sed -i 's/^spring\\.h2\\.console\\.settings\\.web-allow-others=.*/spring.h2.console.settings.web-allow-others=${params.DB_H2_WEB_ALLOWOTHERS}/' src/main/resources/application.properties"
                             }
                             
                             // API Keys and Secrets
                             sh "sed -i 's|^twilio\\.api\\.username=.*|twilio.api.username=${TWILIO_API_USER}|' src/main/resources/application.properties"
                             sh "sed -i 's|^twilio\\.api\\.password=.*|twilio.api.password=${TWILIO_API_PASSWORD}|' src/main/resources/application.properties"
                             sh "sed -i 's|^sendgrid\\.api\\.key=.*|sendgrid.api.key=${SENDGRID_API_KEY}|' src/main/resources/application.properties"
                             sh "sed -i 's|^security\\.jwt\\.token\\.secret-key=.*|security.jwt.token.secret-key=${JWT_SECRET_KEY}|' src/main/resources/application.properties"
                             sh "sed -i 's|^metrc\\.api-key-username=.*|metrc.api-key-username=${METRC_API_KEY_USERNAME}|' src/main/resources/application.properties"
                             sh "sed -i 's|^metrc\\.api-key-password=.*|metrc.api-key-password=${METRC_API_KEY_PASSWORD}|' src/main/resources/application.properties"
                             sh "sed -i 's|^paypal\\.client-id=.*|paypal.client-id=${PAYPAL_CLIENT_ID}|' src/main/resources/application.properties"
                             sh "sed -i 's|^paypal\\.client-secret=.*|paypal.client-secret=${PAYPAL_CLIENT_SECRET}|' src/main/resources/application.properties"
                             sh "sed -i 's|^anthropic\\.apiKey=.*|anthropic.apiKey=${ANTHROPIC_API_KEY}|' src/main/resources/application.properties"
                             
                             // PayPal configuration
                             if (params.PAYPAL_ENVIRONMENT) {
                                 sh "sed -i 's/^paypal\\.environment=.*/paypal.environment=${params.PAYPAL_ENVIRONMENT}/' src/main/resources/application.properties"
                             }
                             if (params.PAYPAL_BRAND_NAME) {
                                 sh "sed -i 's/^paypal\\.brand-name=.*/paypal.brand-name=${params.PAYPAL_BRAND_NAME}/' src/main/resources/application.properties"
                             }
                             
                             // Wallet configuration
                             if (params.WALLET_BRAND) {
                                 sh "sed -i 's/^wallet\\.brand\\.organizationName=.*/wallet.brand.organizationName=${params.WALLET_BRAND}/' src/main/resources/application.properties"
                             }
                             if (params.WALLET_BRAND_PROGRAM) {
                                 sh "sed -i 's/^wallet\\.brand\\.programName=.*/wallet.brand.programName=${params.WALLET_BRAND_PROGRAM}/' src/main/resources/application.properties"
                             }
                             if (params.WALLET_GOOGLE_SERVICE_ACC_KEY_PATH) {
                                 sh "sed -i 's|^wallet\\.google\\.serviceAccountKeyPath=.*|wallet.google.serviceAccountKeyPath=${params.WALLET_GOOGLE_SERVICE_ACC_KEY_PATH}|' src/main/resources/application.properties"
                             }
                             if (params.WALLET_GOOGLE_ISSUER_ID) {
                                 sh "sed -i 's/^wallet\\.google\\.issuerId=.*/wallet.google.issuerId=${params.WALLET_GOOGLE_ISSUER_ID}/' src/main/resources/application.properties"
                             }
                             if (params.WALLET_GOOGLE_CLASS_ID) {
                                 sh "sed -i 's/^wallet\\.google\\.classId=.*/wallet.google.classId=${params.WALLET_GOOGLE_CLASS_ID}/' src/main/resources/application.properties"
                             }
                             
                             // METRC configuration
                             if (params.METRC_MCP_FILE_PATH) {
                                 sh "sed -i 's|^metrc\\.mcp\\.dxtPath=.*|metrc.mcp.dxtPath=${params.METRC_MCP_FILE_PATH}|' src/main/resources/application.properties"
                             }
                             sh "sed -i 's|^metrc\\.mcp\\.url=.*|metrc.mcp.url=${baseQrDomain}/api/mcp|' src/main/resources/application.properties"
                             
                             // Digital Ocean configuration
                             sh "sed -i 's|^digitalocean\\.api\\.token=.*|digitalocean.api.token=${DO_API_TOKEN}|' src/main/resources/application.properties"
                             sh "sed -i 's|^digitalocean\\.domain=.*|digitalocean.domain=${DO_DOMAIN}|' src/main/resources/application.properties"
                             sh "sed -i 's|^digitalocean\\.target\\.loadbalancer=.*|digitalocean.target.loadbalancer=${DO_LB_IP}|' src/main/resources/application.properties"
                             sh "sed -i 's|^digitalocean\\.postgresql\\.username=.*|digitalocean.postgresql.username=${SANDBOX_POSTGRESQL_PUBLIC_USER}|' src/main/resources/application.properties"
                             sh "sed -i 's|^digitalocean\\.postgresql\\.password=.*|digitalocean.postgresql.password=${SANDBOX_POSTGRESQL_PASSWORD}|' src/main/resources/application.properties"
                             sh "sed -i 's|^digitalocean\\.postgresql\\.uri=.*|digitalocean.postgresql.uri=${SANDBOX_POSTGRESQL_PUBLIC_URI}|' src/main/resources/application.properties"
                             
                             // Jenkins configuration
                             sh "sed -i 's|^jenkins\\.username=.*|jenkins.username=${JENKINS_USERNAME}|' src/main/resources/application.properties"
                             sh "sed -i 's|^jenkins\\.token=.*|jenkins.token=${JENKINS_API_TOKEN}|' src/main/resources/application.properties"
                             
                             // Update kubeconfig path to point to the copied file
                            echo "Updating kubernetes.kubeconfig.path to: file:/app/kubeconfig/tulip-sandbox-kubeconfig.yaml"

                             sh "sed -i 's|^kubernetes\\.kubeconfig\\.path=.*|kubernetes.kubeconfig.path=file:/app/kubeconfig/tulip-sandbox-kubeconfig.yaml|' src/main/resources/application.properties"
                             
                             // Verify the kubeconfig file exists
                             sh """
                                 if [ -f "kubeconfig/tulip-sandbox-kubeconfig.yaml" ]; then
                                     echo "Kubeconfig file verified: kubeconfig/tulip-sandbox-kubeconfig.yaml"
                                 else
                                     echo "ERROR: Kubeconfig file not found at expected location"
                                     echo "Current directory contents:"
                                     ls -la
                                     echo "Kubeconfig directory contents:"
                                     ls -la kubeconfig/ || echo "Kubeconfig directory does not exist"
                                     exit 1
                                 fi
                             """

                             sh """
                                    echo "=== SCHEMA CONFIGURATION VERIFICATION ==="
                                 grep "default_schema" src/main/resources/application.properties || echo "ERROR: default_schema not found!"
"""
                        }
                    }
                }
            }
        }

        stage('Build Application') {
            steps {
                dir('inventory') {
                    sh 'mvn clean package -DskipTests'
                }
            }
        }

        stage('Build Docker Image') {
            steps {
                script {
                    def imageName = "${params.DOCKER_USER}/inventory-${params.TENANT_NAME}-${params.APP_NAME}:${UUID.randomUUID().toString()}".toLowerCase()
                    def jarFile = "inventory/target/inventory-0.0.1-SNAPSHOT.jar"
                    
                    // Log Docker build information
                    echo "=========================================="
                    echo "DOCKER BUILD INFORMATION"
                    echo "=========================================="
                    echo ""
                    echo "üê≥ DOCKER CONFIGURATION:"
                    echo "  DOCKER_USER: ${params.DOCKER_USER}"
                    echo "  TENANT_NAME: ${params.TENANT_NAME}"
                    echo "  APP_NAME: ${params.APP_NAME}"
                    echo "  IMAGE_NAME: ${imageName}"
                    echo "  JAR_FILE: ${jarFile}"
                    echo ""
                    echo "=========================================="
                    echo "END OF DOCKER BUILD INFORMATION"
                    echo "=========================================="
                    
                    // Create Dockerfile with kubeconfig path
                    sh """
                        # Check if kubeconfig was created successfully
                        if [ -f inventory/kubeconfig/tulip-sandbox-kubeconfig.yaml ]; then
                            echo "Kubeconfig file found at: inventory/kubeconfig/tulip-sandbox-kubeconfig.yaml"
                            ls -la inventory/kubeconfig/
                        else
                            echo "ERROR: Kubeconfig file not found at expected location"
                            echo "Checking inventory directory:"
                            ls -la inventory/ || echo "Inventory directory does not exist"
                            exit 1
                        fi
                    """
                    
                    // Create Dockerfile
                    writeFile file: 'Dockerfile', text: """
FROM openjdk:17-jdk-slim

# Set working directory
WORKDIR /app

# Copy the JAR file
COPY ${jarFile} app.jar

# Copy the kubeconfig file
COPY inventory/kubeconfig/tulip-sandbox-kubeconfig.yaml /app/kubeconfig/tulip-sandbox-kubeconfig.yaml

# Create necessary directories
RUN mkdir -p /app/logs /app/data /app/uploads /app/kubeconfig

# Expose port
EXPOSE 8080

# Set environment variables
ENV SPRING_PROFILES_ACTIVE=${params.ENVIRONMENT_NAME}
ENV SERVER_PORT=8080

# Run the application
CMD ["java", "-jar", "app.jar"]
"""
                    
                    // Build Docker image
                    docker.build(imageName)
                    
                    // Store image name for later use
                    env.DOCKER_IMAGE = imageName
                }
            }
        }

        stage('Push Docker Image') {
            steps {
                script {
                    withCredentials([string(credentialsId: 'DOCKER_TOKEN', variable: 'DOCKER_TOKEN')]) {
                        sh """
                            echo "$DOCKER_TOKEN" | docker login -u ${params.DOCKER_USER} --password-stdin
                            docker push ${env.DOCKER_IMAGE}
                        """
                    }
                }
            }
        }

        stage('Deploy to Kubernetes') {
            when {
                expression { params.TENANT_NAME != '' }
            }
            steps {
                script {
                    // Create Kubernetes deployment manifest with persistent volume
                    def k8sNamespace = (params.K8S_NAMESPACE && params.K8S_NAMESPACE.trim() != '') ? params.K8S_NAMESPACE : "tenant-${params.TENANT_NAME.toLowerCase().replaceAll('[^a-z0-9-]', '-')}"
                    echo "Constructed Kubernetes namespace: ${k8sNamespace}"
                    echo "TENANT_NAME parameter: ${params.TENANT_NAME}"
                    echo "K8S_NAMESPACE parameter: '${params.K8S_NAMESPACE}'"
                    echo "K8S_NAMESPACE parameter length: ${params.K8S_NAMESPACE?.length() ?: 'null'}"
                    def deploymentYaml = """
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: inventory-${params.TENANT_NAME}-uploads-pvc
  namespace: ${k8sNamespace}
  labels:
    app: inventory
    tenant: ${params.TENANT_NAME}
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 10Gi
  storageClassName: do-block-storage
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: inventory-${params.TENANT_NAME}
  namespace: ${k8sNamespace}
  labels:
    app: inventory
    tenant: ${params.TENANT_NAME}
spec:
  replicas: 1
  selector:
    matchLabels:
      app: inventory
      tenant: ${params.TENANT_NAME}
  template:
    metadata:
      labels:
        app: inventory
        tenant: ${params.TENANT_NAME}
    spec:
      serviceAccountName: ${params.TENANT_NAME}-admin
      containers:
      - name: inventory
        image: ${env.DOCKER_IMAGE}
        ports:
        - containerPort: 8080
        env:
        - name: SPRING_PROFILES_ACTIVE
          value: "${params.ENVIRONMENT_NAME}"
        - name: SERVER_PORT
          value: "8080"
        resources:
          requests:
            memory: "512Mi"
            cpu: "250m"
          limits:
            memory: "1Gi"
            cpu: "500m"
        volumeMounts:
        - name: logs
          mountPath: /app/logs
        - name: data
          mountPath: /app/data
        - name: uploads
          mountPath: /app/uploads
      volumes:
      - name: logs
        emptyDir: {}
      - name: data
        emptyDir: {}
      - name: uploads
        persistentVolumeClaim:
          claimName: inventory-${params.TENANT_NAME}-uploads-pvc
---
apiVersion: v1
kind: Service
metadata:
  name: inventory-${params.TENANT_NAME}-service
  namespace: ${k8sNamespace}
  labels:
    app: inventory
    tenant: ${params.TENANT_NAME}
  annotations:
    service.beta.kubernetes.io/do-loadbalancer-name: "inventory-${params.TENANT_NAME}-lb"
    service.beta.kubernetes.io/do-loadbalancer-algorithm: "round_robin"
    service.beta.kubernetes.io/do-loadbalancer-protocol: "http"
    service.beta.kubernetes.io/do-loadbalancer-tls-passthrough: "false"
    service.beta.kubernetes.io/do-loadbalancer-certificate-id: "${params.TENANT_NAME}.${DO_DOMAIN}"
spec:
  selector:
    app: inventory
    tenant: ${params.TENANT_NAME}
  ports:
  - name: http
    port: 80
    targetPort: 8080
    protocol: TCP
  - name: https
    port: 443
    targetPort: 8080
    protocol: TCP
  type: LoadBalancer
"""
                    
                    // Write deployment manifest to file
                    writeFile file: 'k8s-deployment.yaml', text: deploymentYaml
                    
                    // Apply the deployment using kubectl with file credential
                    withCredentials(
                    [file(credentialsId: 'KUBECONFIG_PATH', variable: 'KCFG')],
                    [string(credentialsId: 'DO_DOMAIN', variable: 'DO_DOMAIN')]
                    ) {
                        sh """
                            export KUBECONFIG="\$KCFG"
                            
                            # Verify kubectl can connect to the cluster
                            kubectl config get-contexts
                            kubectl cluster-info
                            
                            # Check if the service account exists in the namespace
                            echo "DEBUG: k8sNamespace variable = ${k8sNamespace}"
                            echo "Checking for service account ${params.TENANT_NAME}-admin in namespace ${k8sNamespace}"
                            kubectl get serviceaccount ${params.TENANT_NAME}-admin -n ${k8sNamespace} || {
                                echo "ERROR: Service account ${params.TENANT_NAME}-admin not found in namespace ${k8sNamespace}"
                                echo "Available service accounts in namespace ${k8sNamespace}:"
                                kubectl get serviceaccounts -n ${k8sNamespace}
                                exit 1
                            }
                            
                            # Apply the deployment
                            kubectl apply -f k8s-deployment.yaml
                            kubectl rollout status deployment/inventory-${params.TENANT_NAME} -n ${k8sNamespace} --timeout=300s
                            
                            # Wait for LoadBalancer to get external IP
                            echo "Waiting for LoadBalancer to get external IP..."
                            timeout=300
                            while [ \$timeout -gt 0 ]; do
                                EXTERNAL_IP=\$(kubectl get service inventory-${params.TENANT_NAME}-service -n ${k8sNamespace} -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
                                if [ -n "\$EXTERNAL_IP" ] && [ "\$EXTERNAL_IP" != "null" ]; then
                                    echo "LoadBalancer external IP: \$EXTERNAL_IP"
                                    break
                                fi
                                echo "Waiting for external IP... (\$timeout seconds remaining)"
                                sleep 10
                                timeout=\$((timeout - 10))
                            done
                            
                            if [ -z "\$EXTERNAL_IP" ] || [ "\$EXTERNAL_IP" = "null" ]; then
                                echo "ERROR: LoadBalancer did not get external IP within timeout"
                                kubectl get service inventory-${params.TENANT_NAME}-service -n ${k8sNamespace}
                                exit 1
                            fi
                            
                            # Update DNS record with LoadBalancer IP
                            echo "Updating DNS record for ${params.TENANT_NAME}.${DO_DOMAIN} to point to \$EXTERNAL_IP"
                            
                            # Store the external IP for DNS record creation
                            echo "EXTERNAL_IP=\$EXTERNAL_IP" > external_ip.env
                            echo "DNS record should point ${params.TENANT_NAME}.${DO_DOMAIN} to \$EXTERNAL_IP"
                            
                        """
                    }
                }
            }
        }

        stage('Create DNS Record') {
            when {
                expression { params.TENANT_NAME != '' }
            }
            steps {
                script {
                    withCredentials([
                        string(credentialsId: 'DO_API_TOKEN', variable: 'DO_API_TOKEN'),
                        string(credentialsId: 'DO_DOMAIN', variable: 'DO_DOMAIN')
                    ]) {
                        sh """
                            # Read the external IP from the previous stage
                            if [ -f external_ip.env ]; then
                                source external_ip.env
                                echo "Creating DNS record for ${params.TENANT_NAME}.${DO_DOMAIN} -> \$EXTERNAL_IP"
                                
                                # Create DNS A record using DigitalOcean API
                                curl -X POST "https://api.digitalocean.com/v2/domains/${DO_DOMAIN}/records" \\
                                    -H "Content-Type: application/json" \\
                                    -H "Authorization: Bearer \$DO_API_TOKEN" \\
                                    -d '{
                                        "type": "A",
                                        "name": "${params.TENANT_NAME}",
                                        "data": "'\$EXTERNAL_IP'",
                                        "ttl": 3600
                                    }'
                                
                                echo "DNS record creation completed"
                            else
                                echo "ERROR: external_ip.env file not found"
                                exit 1
                            fi
                        """
                    }
                }
            }
        }
    }

    post {
        success {
            echo "Deployment completed successfully for tenant: ${params.TENANT_NAME}"
            echo "Docker image: ${env.DOCKER_IMAGE}"
            script {
                def k8sNamespace = params.K8S_NAMESPACE ?: "tenant-${params.TENANT_NAME.toLowerCase().replaceAll('[^a-z0-9-]', '-')}"
                echo "Kubernetes namespace: ${k8sNamespace}"
            }
        }
        failure {
            echo "Deployment failed for tenant: ${params.TENANT_NAME}"
        }
        always {
            // Clean up temporary files
            sh 'rm -f Dockerfile k8s-deployment.yaml external_ip.env'
        }
    }
}
