pipeline {
    agent any

    tools {
        maven 'maven3'
    }

    parameters {
        // Build parameters
        string(name: 'BRANCH', defaultValue: 'test1', description: 'Branch to build from')
        string(name: 'TENANT_NAME', defaultValue: '', description: 'Tenant name for deployment')
        string(name: 'APP_NAME', defaultValue: 'inventory', description: 'Application name')
        string(name: 'DO_DOMAIN', defaultValue: '', description: 'the domain')
        string(name: 'SUBSCRIPTION_TIER', defaultValue: 'BASIC', description: 'Subscription tier')
        string(name: 'BILLING_EMAIL', defaultValue: '', description: 'Billing email address')
        string(name: 'K8S_NAMESPACE', defaultValue: '', description: 'Kubernetes namespace (auto-generated if empty)')

        // DigitalOcean parameters
        string(name: 'DO_LOADBALANCER_ID', defaultValue: '', description: 'DigitalOcean Load Balancer ID for Kubernetes Service annotation')
        
        // Docker parameters
        string(name: 'DOCKER_USER', defaultValue: 'techvvsadmin', description: 'Docker Hub username')
        
        // Application configuration parameters
        string(name: 'ENVIRONMENT_NAME', defaultValue: 'prod', description: 'Environment name (prod, dev1)')
        string(name: 'LOAD_REF_DATA', defaultValue: 'no', description: 'Load reference data (yes/no)')
        string(name: 'TAX_PERCENTAGE', defaultValue: '0', description: 'Tax percentage')
        string(name: 'MAX_FILE_SIZE', defaultValue: '500MB', description: 'Maximum file size')
        string(name: 'MAX_REQ_SIZE', defaultValue: '500MB', description: 'Maximum request size')
        
        // Database configuration
        string(name: 'DB_DRIVER_CLASS_NAME', defaultValue: 'org.postgresql.Driver', description: 'Database driver class')
        string(name: 'DB_JPA_DATABASE_PLATFORM', defaultValue: 'org.hibernate.dialect.PostgreSQLDialect', description: 'JPA database platform')
        string(name: 'DB_JPA_HIBERNATE_DIALECT', defaultValue: 'org.hibernate.dialect.PostgreSQLDialect', description: 'Hibernate dialect')
        string(name: 'DB_USERNAME', defaultValue: 'doadmin', description: 'Database username')
        string(name: 'SANDBOX_POSTGRESQL_URI', defaultValue: 'jdbc:postgresql://private-sandbox-cluster-do-user-1326368-0.e.db.ondigitalocean.com:25060', description: 'Database uri')
        string(name: 'DB_URI', defaultValue: 'jdbc:postgresql://private-sandbox-cluster-do-user-1326368-0.e.db.ondigitalocean.com:25060', description: 'Database uri')
        string(name: 'SPRING_DATABASE_ACTION', defaultValue: 'update', description: 'Database action (update, create-drop)')
        string(name: 'DB_H2_CONSOLE_ENABLED', defaultValue: 'false', description: 'Enable H2 console')
        string(name: 'DB_H2_WEB_ALLOWOTHERS', defaultValue: 'false', description: 'Allow others to access H2 console')
        
        // PayPal configuration
        string(name: 'PAYPAL_ENVIRONMENT', defaultValue: 'SANDBOX', description: 'PayPal environment (SANDBOX/PRODUCTION)')
        string(name: 'PAYPAL_BRAND_NAME', defaultValue: 'techvvs_clothing_app_1', description: 'PayPal brand name')
        
        // Wallet configuration
        string(name: 'WALLET_BRAND', defaultValue: 'Tulip', description: 'Wallet brand organization name')
        string(name: 'WALLET_BRAND_PROGRAM', defaultValue: 'Tulip Membership', description: 'Wallet brand program name')
        string(name: 'WALLET_GOOGLE_SERVICE_ACC_KEY_PATH', defaultValue: 'classpath:/uploads/applecert/', description: 'Google service account key path')
        string(name: 'WALLET_GOOGLE_ISSUER_ID', defaultValue: '', description: 'Google wallet issuer ID')
        string(name: 'WALLET_GOOGLE_CLASS_ID', defaultValue: '', description: 'Google wallet class ID')
        
        // METRC configuration
        string(name: 'METRC_MCP_FILE_PATH', defaultValue: 'classpath:/uploads/mcp/metrc-mcp-connector.dxt', description: 'METRC MCP file path')
        
        // Request logging configuration
        string(name: 'REQUEST_LOGGING_ENABLED', defaultValue: 'true', description: 'Enable request logging')
        string(name: 'REQUEST_LOGGING_HEADERS', defaultValue: 'true', description: 'Log request headers')
        string(name: 'REQUEST_LOGGING_DEVICE_INFO', defaultValue: 'true', description: 'Log device info')
        string(name: 'REQUEST_LOGGING_SESSION_INFO', defaultValue: 'true', description: 'Log session info')
        string(name: 'REQUEST_LOGGING_SECURITY_INFO', defaultValue: 'false', description: 'Log security info')
    }

    stages {
        stage('Checkout') {
            steps {
                checkout([
                    $class: 'GitSCM',
                    branches: [[name: "*/${params.BRANCH}"]],
                    userRemoteConfigs: [[url: 'https://github.com/javascriptjenkins/inventory.git', credentialsId: 'githubcreds']]
                ])
            }
        }

        stage('Log Build Parameters') {
            steps {
                script {
                    echo "=========================================="
                    echo "JENKINS BUILD PARAMETERS LOG"
                    echo "=========================================="
                    echo ""
                    
                    echo "ðŸ“‹ BUILD PARAMETERS:"
                    echo "  BRANCH: ${params.BRANCH}"
                    echo "  TENANT_NAME: ${params.TENANT_NAME}"
                    echo "  APP_NAME: ${params.APP_NAME}"
                    echo "  SUBSCRIPTION_TIER: ${params.SUBSCRIPTION_TIER}"
                    echo "  BILLING_EMAIL: ${params.BILLING_EMAIL}"
                    echo "  K8S_NAMESPACE: ${params.K8S_NAMESPACE}"
                    
                    echo "ðŸŒ DIGITALOCEAN PARAMETERS:"
                    echo "  DO_LOADBALANCER_ID: ${params.DO_LOADBALANCER_ID}"
                    echo ""
                    
                    echo "ðŸ³ DOCKER PARAMETERS:"
                    echo "  DOCKER_USER: ${params.DOCKER_USER}"
                    echo ""
                    
                    echo "âš™ï¸ APPLICATION CONFIGURATION:"
                    echo "  ENVIRONMENT_NAME: ${params.ENVIRONMENT_NAME}"
                    echo "  LOAD_REF_DATA: ${params.LOAD_REF_DATA}"
                    echo "  TAX_PERCENTAGE: ${params.TAX_PERCENTAGE}"
                    echo "  MAX_FILE_SIZE: ${params.MAX_FILE_SIZE}"
                    echo "  MAX_REQ_SIZE: ${params.MAX_REQ_SIZE}"
                    echo ""
                    
                    echo "ðŸ—„ï¸ DATABASE CONFIGURATION:"
                    echo "  DB_DRIVER_CLASS_NAME: ${params.DB_DRIVER_CLASS_NAME}"
                    echo "  DB_JPA_DATABASE_PLATFORM: ${params.DB_JPA_DATABASE_PLATFORM}"
                    echo "  DB_JPA_HIBERNATE_DIALECT: ${params.DB_JPA_HIBERNATE_DIALECT}"
                    echo "  DB_USERNAME: ${params.DB_USERNAME}"
                    echo "  SANDBOX_POSTGRESQL_URI: ${params.SANDBOX_POSTGRESQL_URI}"
                    echo "  env.DB_URI: ${env.DB_URI}"
                    echo "  SPRING_DATABASE_ACTION: ${params.SPRING_DATABASE_ACTION}"
                    echo "  DB_H2_CONSOLE_ENABLED: ${params.DB_H2_CONSOLE_ENABLED}"
                    echo "  DB_H2_WEB_ALLOWOTHERS: ${params.DB_H2_WEB_ALLOWOTHERS}"
                    echo ""
                    
                    echo "ðŸ’³ PAYPAL CONFIGURATION:"
                    echo "  PAYPAL_ENVIRONMENT: ${params.PAYPAL_ENVIRONMENT}"
                    echo "  PAYPAL_BRAND_NAME: ${params.PAYPAL_BRAND_NAME}"
                    echo ""
                    
                    echo "ðŸ’› WALLET CONFIGURATION:"
                    echo "  WALLET_BRAND: ${params.WALLET_BRAND}"
                    echo "  WALLET_BRAND_PROGRAM: ${params.WALLET_BRAND_PROGRAM}"
                    echo "  WALLET_GOOGLE_SERVICE_ACC_KEY_PATH: ${params.WALLET_GOOGLE_SERVICE_ACC_KEY_PATH}"
                    echo "  WALLET_GOOGLE_ISSUER_ID: ${params.WALLET_GOOGLE_ISSUER_ID}"
                    echo "  WALLET_GOOGLE_CLASS_ID: ${params.WALLET_GOOGLE_CLASS_ID}"
                    echo ""
                    
                    echo "ðŸŒ¿ METRC CONFIGURATION:"
                    echo "  METRC_MCP_FILE_PATH: ${params.METRC_MCP_FILE_PATH}"
                    echo ""
                    
                    echo "ðŸ“Š REQUEST LOGGING CONFIGURATION:"
                    echo "  REQUEST_LOGGING_ENABLED: ${params.REQUEST_LOGGING_ENABLED}"
                    echo "  REQUEST_LOGGING_HEADERS: ${params.REQUEST_LOGGING_HEADERS}"
                    echo "  REQUEST_LOGGING_DEVICE_INFO: ${params.REQUEST_LOGGING_DEVICE_INFO}"
                    echo "  REQUEST_LOGGING_SESSION_INFO: ${params.REQUEST_LOGGING_SESSION_INFO}"
                    echo "  REQUEST_LOGGING_SECURITY_INFO: ${params.REQUEST_LOGGING_SECURITY_INFO}"
                    echo ""
                    
                    echo "=========================================="
                    echo "END OF BUILD PARAMETERS LOG"
                    echo "=========================================="
                }
            }
        }

        stage('Update Application Properties') {
            steps {
                script {
                    withCredentials([
                        // API Keys and Secrets
                        string(credentialsId: 'TWILIO_API_USER', variable: 'TWILIO_API_USER'),
                        string(credentialsId: 'TWILIO_API_PASSWORD', variable: 'TWILIO_API_PASSWORD'),
                        string(credentialsId: 'SENDGRID_API_KEY', variable: 'SENDGRID_API_KEY'),
                        string(credentialsId: 'JWT_SECRET_KEY', variable: 'JWT_SECRET_KEY'),
                        string(credentialsId: 'METRC_API_KEY_USERNAME', variable: 'METRC_API_KEY_USERNAME'),
                        string(credentialsId: 'METRC_API_KEY_PASSWORD', variable: 'METRC_API_KEY_PASSWORD'),
                        string(credentialsId: 'PAYPAL_CLIENT_ID', variable: 'PAYPAL_CLIENT_ID'),
                        string(credentialsId: 'PAYPAL_CLIENT_SECRET', variable: 'PAYPAL_CLIENT_SECRET'),
                        string(credentialsId: 'ANTHROPIC_API_KEY', variable: 'ANTHROPIC_API_KEY'),
                        
                        // Database credentials
                        string(credentialsId: 'DB_PASSWORD', variable: 'DB_PASSWORD'),
                        string(credentialsId: 'POSTGRE_TEST_DB_PASSWORD', variable: 'POSTGRE_TEST_DB_PASSWORD'),
                        string(credentialsId: 'POSTGRE_PROD_DB_PASSWORD', variable: 'POSTGRE_PROD_DB_PASSWORD'),
                        string(credentialsId: 'POSTGRE_ALPHA_DB_PASSWORD', variable: 'POSTGRE_ALPHA_DB_PASSWORD'),
                        
                        // Digital Ocean credentials
                        string(credentialsId: 'DO_API_TOKEN', variable: 'DO_API_TOKEN'),
                        string(credentialsId: 'DO_LB_IP', variable: 'DO_LB_IP'),
                        string(credentialsId: 'SANDBOX_POSTGRESQL_PUBLIC_USER', variable: 'SANDBOX_POSTGRESQL_PUBLIC_USER'),
                        string(credentialsId: 'SANDBOX_POSTGRESQL_PUBLIC_URI', variable: 'SANDBOX_POSTGRESQL_PUBLIC_URI'),
                        string(credentialsId: 'SANDBOX_POSTGRESQL_PASSWORD', variable: 'SANDBOX_POSTGRESQL_PASSWORD'),
                        
                        // Jenkins credentials
                        string(credentialsId: 'JENKINS_USERNAME', variable: 'JENKINS_USERNAME'),
                        string(credentialsId: 'JENKINS_API_TOKEN', variable: 'JENKINS_API_TOKEN'),

                        // Kubernetes config file
                        file(credentialsId: 'KUBECONFIG_PATH', variable: 'KUBECONFIG_FILE')
                    ]) {
                        // Log credentials being used (without exposing actual values)
                        echo "=========================================="
                        echo "CREDENTIALS BEING USED (IDs only for security)"
                        echo "=========================================="
                        echo ""
                        
                        echo "ðŸ” API KEYS AND SECRETS:"
                        echo "  TWILIO_API_USER: [CREDENTIAL ID: TWILIO_API_USER]"
                        echo "  TWILIO_API_PASSWORD: [CREDENTIAL ID: TWILIO_API_PASSWORD]"
                        echo "  SENDGRID_API_KEY: [CREDENTIAL ID: SENDGRID_API_KEY]"
                        echo "  JWT_SECRET_KEY: [CREDENTIAL ID: JWT_SECRET_KEY]"
                        echo "  METRC_API_KEY_USERNAME: [CREDENTIAL ID: METRC_API_KEY_USERNAME]"
                        echo "  METRC_API_KEY_PASSWORD: [CREDENTIAL ID: METRC_API_KEY_PASSWORD]"
                        echo "  PAYPAL_CLIENT_ID: [CREDENTIAL ID: PAYPAL_CLIENT_ID]"
                        echo "  PAYPAL_CLIENT_SECRET: [CREDENTIAL ID: PAYPAL_CLIENT_SECRET]"
                        echo "  ANTHROPIC_API_KEY: [CREDENTIAL ID: ANTHROPIC_API_KEY]"
                        echo ""
                        
                        echo "ðŸ—„ï¸ DATABASE CREDENTIALS:"
                        echo "  DB_PASSWORD: [CREDENTIAL ID: DB_PASSWORD]"
                        echo "  POSTGRE_TEST_DB_PASSWORD: [CREDENTIAL ID: POSTGRE_TEST_DB_PASSWORD]"
                        echo "  POSTGRE_PROD_DB_PASSWORD: [CREDENTIAL ID: POSTGRE_PROD_DB_PASSWORD]"
                        echo "  POSTGRE_ALPHA_DB_PASSWORD: [CREDENTIAL ID: POSTGRE_ALPHA_DB_PASSWORD]"
                        echo "  SANDBOX_POSTGRESQL_PUBLIC_USER: [CREDENTIAL ID: SANDBOX_POSTGRESQL_PUBLIC_USER]"
                        echo "  SANDBOX_POSTGRESQL_PUBLIC_URI: [CREDENTIAL ID: SANDBOX_POSTGRESQL_PUBLIC_URI]"
                        echo "  SANDBOX_POSTGRESQL_PASSWORD: [CREDENTIAL ID: SANDBOX_POSTGRESQL_PASSWORD]"
                        echo ""
                        
                        echo "ðŸŒ DIGITALOCEAN CREDENTIALS:"
                        echo "  DO_API_TOKEN: [CREDENTIAL ID: DO_API_TOKEN]"
                        echo "  DO_LB_IP: [CREDENTIAL ID: DO_LB_IP]"
                        echo ""
                        
                        echo "ðŸ”§ JENKINS CREDENTIALS:"
                        echo "  JENKINS_USERNAME: [CREDENTIAL ID: JENKINS_USERNAME]"
                        echo "  JENKINS_API_TOKEN: [CREDENTIAL ID: JENKINS_API_TOKEN]"
                        echo ""
                        
                        echo "â˜¸ï¸ KUBERNETES CONFIGURATION:"
                        echo "  KUBECONFIG_PATH: [CREDENTIAL ID: KUBECONFIG_PATH]"
                        echo ""
                        
                        echo "=========================================="
                        echo "END OF CREDENTIALS LOG"
                        echo "=========================================="
                        
                        dir('inventory') {
                            // Copy kubeconfig to a writable location and update the path in application.properties
                            // Create kubeconfig from string content
                            sh "mkdir -p kubeconfig"
                            sh "cp ${KUBECONFIG_FILE} kubeconfig/tulip-sandbox-kubeconfig.yaml"
                            sh "chmod 600 kubeconfig/tulip-sandbox-kubeconfig.yaml"

                             // Construct BASE_QR_DOMAIN from tenant name and DO domain
                             def baseQrDomain = "https://${params.TENANT_NAME}.${params.DO_DOMAIN}"
                             echo "Constructed BASE_QR_DOMAIN: ${baseQrDomain}"
                             
                             // Construct Kubernetes namespace from tenant name (same logic as Java code)
                             def k8sNamespace = params.K8S_NAMESPACE ?: "tenant-${params.TENANT_NAME.toLowerCase().replaceAll('[^a-z0-9-]', '-')}"
                             echo "Using Kubernetes namespace: ${k8sNamespace}"
                             
                             // Log all dynamic values being used
                             echo "=========================================="
                             echo "DYNAMIC VALUES CALCULATED DURING BUILD"
                             echo "=========================================="
                             echo ""
                             echo "ðŸŒ DYNAMIC DOMAIN CONFIGURATION:"
                             echo "  BASE_QR_DOMAIN: ${baseQrDomain}"
                             echo "  METRC_MCP_URI: ${baseQrDomain}/api/mcp"
                             echo ""
                             echo "â˜¸ï¸ KUBERNETES CONFIGURATION:"
                             echo "  K8S_NAMESPACE: ${k8sNamespace}"
                             echo ""
                             echo "=========================================="
                             echo "END OF DYNAMIC VALUES LOG"
                             echo "=========================================="
                             
                             // Update application.properties with all parameters
                             // Basic application settings
                             if (params.ENVIRONMENT_NAME) {
                                 sh "sed -i 's/^spring\\.profiles\\.active=.*/spring.profiles.active=${params.ENVIRONMENT_NAME}/' src/main/resources/application.properties"
                             }
                             if (params.LOAD_REF_DATA) {
                                 sh "sed -i 's/^load\\.ref\\.data=.*/load.ref.data=${params.LOAD_REF_DATA}/' src/main/resources/application.properties"
                             }
                             if (params.TAX_PERCENTAGE) {
                                 sh "sed -i 's/^tax\\.percentage=.*/tax.percentage=${params.TAX_PERCENTAGE}/' src/main/resources/application.properties"
                             }
                             sh "sed -i 's|^base\\.qr\\.domain=.*|base.qr.domain=${baseQrDomain}|' src/main/resources/application.properties"
                             if (params.MAX_FILE_SIZE) {
                                 sh "sed -i 's/^spring\\.servlet\\.multipart\\.max-file-size=.*/spring.servlet.multipart.max-file-size=${params.MAX_FILE_SIZE}/' src/main/resources/application.properties"
                             }
                             if (params.MAX_REQ_SIZE) {
                                 sh "sed -i 's/^spring\\.servlet\\.multipart\\.max-request-size=.*/spring.servlet.multipart.max-request-size=${params.MAX_REQ_SIZE}/' src/main/resources/application.properties"
                             }
                             
                             // Database settings
                             sh "sed -i 's|^spring\\.datasource\\.url=.*|spring.datasource.url=${params.DB_URI}/defaultdb?currentSchema=tenant_${params.TENANT_NAME}&sslmode=require|' src/main/resources/application.properties"
                             sh "echo 'Updated DB_URI: ${params.DB_URI}/defaultdb?currentSchema=tenant_${params.TENANT_NAME}&sslmode=require'"
                             if (params.DB_DRIVER_CLASS_NAME) {
                                 sh "sed -i 's/^spring\\.datasource\\.driver-class-name=.*/spring.datasource.driver-class-name=${params.DB_DRIVER_CLASS_NAME}/' src/main/resources/application.properties"
                             }
                             if (params.DB_JPA_DATABASE_PLATFORM) {
                                 sh "sed -i 's/^spring\\.jpa\\.database-platform=.*/spring.jpa.database-platform=${params.DB_JPA_DATABASE_PLATFORM}/' src/main/resources/application.properties"
                             }
                             if (params.DB_JPA_HIBERNATE_DIALECT) {
                                 sh "sed -i 's/^spring\\.jpa\\.properties\\.hibernate\\.dialect=.*/spring.jpa.properties.hibernate.dialect=${params.DB_JPA_HIBERNATE_DIALECT}/' src/main/resources/application.properties"
                             }
                            sh "sed -i 's/^spring\\.datasource\\.username=.*/spring.datasource.username=${SANDBOX_POSTGRESQL_PUBLIC_USER}/' src/main/resources/application.properties"
                            sh "sed -i 's/^spring\\.datasource\\.password=.*/spring.datasource.password=${SANDBOX_POSTGRESQL_PASSWORD}/' src/main/resources/application.properties"
                            sh "sed -i 's/^spring\\.jpa\\.properties\\.hibernate\\.default_schema=.*/spring.jpa.properties.hibernate.default_schema=${params.TENANT_NAME}/' src/main/resources/application.properties"

                             if (params.SPRING_DATABASE_ACTION) {
                                 sh "sed -i 's/^spring\\.jpa\\.hibernate\\.ddl-auto=.*/spring.jpa.hibernate.ddl-auto=${params.SPRING_DATABASE_ACTION}/' src/main/resources/application.properties"
                             }
                             if (params.DB_H2_CONSOLE_ENABLED) {
                                 sh "sed -i 's/^spring\\.h2\\.console\\.enabled=.*/spring.h2.console.enabled=${params.DB_H2_CONSOLE_ENABLED}/' src/main/resources/application.properties"
                             }
                             if (params.DB_H2_WEB_ALLOWOTHERS) {
                                 sh "sed -i 's/^spring\\.h2\\.console\\.settings\\.web-allow-others=.*/spring.h2.console.settings.web-allow-others=${params.DB_H2_WEB_ALLOWOTHERS}/' src/main/resources/application.properties"
                             }
                             
                             // API Keys and Secrets
                             sh "sed -i 's|^twilio\\.api\\.username=.*|twilio.api.username=${TWILIO_API_USER}|' src/main/resources/application.properties"
                             sh "sed -i 's|^twilio\\.api\\.password=.*|twilio.api.password=${TWILIO_API_PASSWORD}|' src/main/resources/application.properties"
                             sh "sed -i 's|^sendgrid\\.api\\.key=.*|sendgrid.api.key=${SENDGRID_API_KEY}|' src/main/resources/application.properties"
                             sh "sed -i 's|^security\\.jwt\\.token\\.secret-key=.*|security.jwt.token.secret-key=${JWT_SECRET_KEY}|' src/main/resources/application.properties"
                             sh "sed -i 's|^metrc\\.api-key-username=.*|metrc.api-key-username=${METRC_API_KEY_USERNAME}|' src/main/resources/application.properties"
                             sh "sed -i 's|^metrc\\.api-key-password=.*|metrc.api-key-password=${METRC_API_KEY_PASSWORD}|' src/main/resources/application.properties"
                             sh "sed -i 's|^paypal\\.client-id=.*|paypal.client-id=${PAYPAL_CLIENT_ID}|' src/main/resources/application.properties"
                             sh "sed -i 's|^paypal\\.client-secret=.*|paypal.client-secret=${PAYPAL_CLIENT_SECRET}|' src/main/resources/application.properties"
                             sh "sed -i 's|^anthropic\\.apiKey=.*|anthropic.apiKey=${ANTHROPIC_API_KEY}|' src/main/resources/application.properties"
                             
                             // PayPal configuration
                             if (params.PAYPAL_ENVIRONMENT) {
                                 sh "sed -i 's/^paypal\\.environment=.*/paypal.environment=${params.PAYPAL_ENVIRONMENT}/' src/main/resources/application.properties"
                             }
                             if (params.PAYPAL_BRAND_NAME) {
                                 sh "sed -i 's/^paypal\\.brand-name=.*/paypal.brand-name=${params.PAYPAL_BRAND_NAME}/' src/main/resources/application.properties"
                             }
                             
                             // Wallet configuration
                             if (params.WALLET_BRAND) {
                                 sh "sed -i 's/^wallet\\.brand\\.organizationName=.*/wallet.brand.organizationName=${params.WALLET_BRAND}/' src/main/resources/application.properties"
                             }
                             if (params.WALLET_BRAND_PROGRAM) {
                                 sh "sed -i 's/^wallet\\.brand\\.programName=.*/wallet.brand.programName=${params.WALLET_BRAND_PROGRAM}/' src/main/resources/application.properties"
                             }
                             if (params.WALLET_GOOGLE_SERVICE_ACC_KEY_PATH) {
                                 sh "sed -i 's|^wallet\\.google\\.serviceAccountKeyPath=.*|wallet.google.serviceAccountKeyPath=${params.WALLET_GOOGLE_SERVICE_ACC_KEY_PATH}|' src/main/resources/application.properties"
                             }
                             if (params.WALLET_GOOGLE_ISSUER_ID) {
                                 sh "sed -i 's/^wallet\\.google\\.issuerId=.*/wallet.google.issuerId=${params.WALLET_GOOGLE_ISSUER_ID}/' src/main/resources/application.properties"
                             }
                             if (params.WALLET_GOOGLE_CLASS_ID) {
                                 sh "sed -i 's/^wallet\\.google\\.classId=.*/wallet.google.classId=${params.WALLET_GOOGLE_CLASS_ID}/' src/main/resources/application.properties"
                             }
                             
                             // METRC configuration
                             if (params.METRC_MCP_FILE_PATH) {
                                 sh "sed -i 's|^metrc\\.mcp\\.dxtPath=.*|metrc.mcp.dxtPath=${params.METRC_MCP_FILE_PATH}|' src/main/resources/application.properties"
                             }
                             sh "sed -i 's|^metrc\\.mcp\\.url=.*|metrc.mcp.url=${baseQrDomain}/api/mcp|' src/main/resources/application.properties"
                             
                             // Digital Ocean configuration
                             sh "sed -i 's|^digitalocean\\.api\\.token=.*|digitalocean.api.token=${DO_API_TOKEN}|' src/main/resources/application.properties"
                             sh "sed -i 's|^digitalocean\\.domain=.*|digitalocean.domain=${params.DO_DOMAIN}|' src/main/resources/application.properties"
                             sh "sed -i 's|^digitalocean\\.target\\.loadbalancer=.*|digitalocean.target.loadbalancer=${DO_LB_IP}|' src/main/resources/application.properties"
                             sh "sed -i 's|^digitalocean\\.postgresql\\.username=.*|digitalocean.postgresql.username=${SANDBOX_POSTGRESQL_PUBLIC_USER}|' src/main/resources/application.properties"
                             sh "sed -i 's|^digitalocean\\.postgresql\\.password=.*|digitalocean.postgresql.password=${SANDBOX_POSTGRESQL_PASSWORD}|' src/main/resources/application.properties"
                             sh "sed -i 's|^digitalocean\\.postgresql\\.uri=.*|digitalocean.postgresql.uri=${SANDBOX_POSTGRESQL_PUBLIC_URI}|' src/main/resources/application.properties"
                             
                             // Jenkins configuration
                             sh "sed -i 's|^jenkins\\.username=.*|jenkins.username=${JENKINS_USERNAME}|' src/main/resources/application.properties"
                             sh "sed -i 's|^jenkins\\.token=.*|jenkins.token=${JENKINS_API_TOKEN}|' src/main/resources/application.properties"
                             
                             // Update kubeconfig path to point to the copied file
                            echo "Updating kubernetes.kubeconfig.path to: file:/app/kubeconfig/tulip-sandbox-kubeconfig.yaml"

                             sh "sed -i 's|^kubernetes\\.kubeconfig\\.path=.*|kubernetes.kubeconfig.path=file:/app/kubeconfig/tulip-sandbox-kubeconfig.yaml|' src/main/resources/application.properties"
                             
                             // Verify the kubeconfig file exists
                             sh """
                                 if [ -f "kubeconfig/tulip-sandbox-kubeconfig.yaml" ]; then
                                     echo "Kubeconfig file verified: kubeconfig/tulip-sandbox-kubeconfig.yaml"
                                 else
                                     echo "ERROR: Kubeconfig file not found at expected location"
                                     echo "Current directory contents:"
                                     ls -la
                                     echo "Kubeconfig directory contents:"
                                     ls -la kubeconfig/ || echo "Kubeconfig directory does not exist"
                                     exit 1
                                 fi
                             """

                            sh """
                                echo "=== SCHEMA CONFIGURATION VERIFICATION ==="
                                grep "default_schema" src/main/resources/application.properties || echo "ERROR: default_schema not found!"
                            """
                        }
                    }
                }
            }
        }

        stage('Build Application') {
            steps {
                dir('inventory') {
                    sh 'mvn clean package -DskipTests'
                }
            }
        }

        stage('Build Docker Image') {
            steps {
                script {
                    def imageName = "${params.DOCKER_USER}/inventory-${params.TENANT_NAME}-${params.APP_NAME}:${UUID.randomUUID().toString()}".toLowerCase()
                    def jarFile = "inventory/target/inventory-0.0.1-SNAPSHOT.jar"
                    
                    // Log Docker build information
                    echo "=========================================="
                    echo "DOCKER BUILD INFORMATION"
                    echo "=========================================="
                    echo ""
                    echo "ðŸ³ DOCKER CONFIGURATION:"
                    echo "  DOCKER_USER: ${params.DOCKER_USER}"
                    echo "  TENANT_NAME: ${params.TENANT_NAME}"
                    echo "  APP_NAME: ${params.APP_NAME}"
                    echo "  IMAGE_NAME: ${imageName}"
                    echo "  JAR_FILE: ${jarFile}"
                    echo ""
                    echo "=========================================="
                    echo "END OF DOCKER BUILD INFORMATION"
                    echo "=========================================="
                    
                    // Create Dockerfile with kubeconfig path
                    sh """
                        # Check if kubeconfig was created successfully
                        if [ -f inventory/kubeconfig/tulip-sandbox-kubeconfig.yaml ]; then
                            echo "Kubeconfig file found at: inventory/kubeconfig/tulip-sandbox-kubeconfig.yaml"
                            ls -la inventory/kubeconfig/
                        else
                            echo "ERROR: Kubeconfig file not found at expected location"
                            echo "Checking inventory directory:"
                            ls -la inventory/ || echo "Inventory directory does not exist"
                            exit 1
                        fi
                    """
                    
                    // Create Dockerfile
                    writeFile file: 'Dockerfile', text: """
FROM openjdk:17-jdk-slim

# Install curl for debugging and health checks
RUN apt-get update && apt-get install -y curl && rm -rf /var/lib/apt/lists/*

# Set working directory
WORKDIR /app

# Copy the JAR file
COPY ${jarFile} app.jar

# Copy the kubeconfig file
COPY inventory/kubeconfig/tulip-sandbox-kubeconfig.yaml /app/kubeconfig/tulip-sandbox-kubeconfig.yaml

# Create necessary directories
RUN mkdir -p /app/logs /app/data /app/uploads /app/kubeconfig

# Expose port
EXPOSE 8080

# Set environment variables
ENV SPRING_PROFILES_ACTIVE=${params.ENVIRONMENT_NAME}
ENV SERVER_PORT=8080

# Run the application
CMD ["java", "-jar", "app.jar"]
"""
                    
                    // Build Docker image
                    docker.build(imageName)
                    
                    // Store image name for later use
                    env.DOCKER_IMAGE = imageName
                }
            }
        }

        stage('Push Docker Image') {
            steps {
                script {
                    withCredentials([string(credentialsId: 'DOCKER_TOKEN', variable: 'DOCKER_TOKEN')]) {
                        sh """
                            echo "$DOCKER_TOKEN" | docker login -u ${params.DOCKER_USER} --password-stdin
                            docker push ${env.DOCKER_IMAGE}
                        """
                    }
                }
            }
        }

        stage('Deploy to Kubernetes') {
            when {
                expression { params.TENANT_NAME != '' }
            }
            steps {
                script {
                    def k8sNamespace = (params.K8S_NAMESPACE && params.K8S_NAMESPACE.trim() != '') ?
                        params.K8S_NAMESPACE :
                        "tenant-${params.TENANT_NAME.toLowerCase().replaceAll('[^a-z0-9-]', '-')}"

                    // Bind into an env var so subsequent sh{} or steps can use it
                    env.K8S_NAMESPACE = k8sNamespace
                    echo "Namespace set to: ${env.K8S_NAMESPACE}"

                    echo "Constructed Kubernetes namespace: ${k8sNamespace}"
                    echo "TENANT_NAME parameter: ${params.TENANT_NAME}"
                    echo "K8S_NAMESPACE parameter: '${params.K8S_NAMESPACE}'"
                    echo "K8S_NAMESPACE parameter length: ${params.K8S_NAMESPACE?.length() ?: 'null'}"
                    echo "Workspace directory: ${WORKSPACE}"
                    echo "LoadBalancer name (workspace root): ${WORKSPACE.split('/').last()}"
                    echo "env.CERT_ID before deployment yaml: ${env.CERT_ID}"
                    def deploymentYaml = """
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: inventory-${params.TENANT_NAME}-uploads-pvc
  namespace: ${k8sNamespace}
  labels:
    app: inventory
    tenant: ${params.TENANT_NAME}
spec:
  accessModes: [ReadWriteOnce]
  resources:
    requests:
      storage: 10Gi
  storageClassName: do-block-storage
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: inventory-${params.TENANT_NAME}
  namespace: ${k8sNamespace}
  labels:
    app: inventory
    tenant: ${params.TENANT_NAME}
spec:
  replicas: 1
  selector:
    matchLabels:
      app: inventory
      tenant: ${params.TENANT_NAME}
  template:
    metadata:
      labels:
        app: inventory
        tenant: ${params.TENANT_NAME}
    spec:
      serviceAccountName: ${params.TENANT_NAME}-admin
      containers:
      - name: inventory
        image: ${env.DOCKER_IMAGE}
        ports:
        - containerPort: 8080
        env:
        - name: SPRING_PROFILES_ACTIVE
          value: "${params.ENVIRONMENT_NAME}"
        - name: SERVER_PORT
          value: "8080"
        resources:
          requests:
            memory: "512Mi"
            cpu: "250m"
          limits:
            memory: "1Gi"
            cpu: "500m"
        volumeMounts:
        - name: logs
          mountPath: /app/logs
        - name: data
          mountPath: /app/data
        - name: uploads
          mountPath: /app/uploads
      volumes:
      - name: logs
        emptyDir: {}
      - name: data
        emptyDir: {}
      - name: uploads
        persistentVolumeClaim:
          claimName: inventory-${params.TENANT_NAME}-uploads-pvc
---
apiVersion: v1
kind: Service
metadata:
  name: inventory-${params.TENANT_NAME}-service
  namespace: ${k8sNamespace}
  labels:
    app: inventory
    tenant: ${params.TENANT_NAME}
  annotations:
    service.beta.kubernetes.io/do-loadbalancer-tls-passthrough: "true"
    service.beta.kubernetes.io/do-loadbalancer-healthcheck-protocol: "http"
    service.beta.kubernetes.io/do-loadbalancer-healthcheck-port: "8080"
    service.beta.kubernetes.io/do-loadbalancer-healthcheck-check-interval-seconds: "10"
    service.beta.kubernetes.io/do-loadbalancer-healthcheck-response-timeout-seconds: "5"
    service.beta.kubernetes.io/do-loadbalancer-healthcheck-healthy-threshold: "3"
    service.beta.kubernetes.io/do-loadbalancer-healthcheck-unhealthy-threshold: "3"
    service.beta.kubernetes.io/do-loadbalancer-type: "REGIONAL"

spec:
  type: LoadBalancer
  externalTrafficPolicy: Local
  selector:
    app: inventory
    tenant: ${params.TENANT_NAME}
  ports:
  - name: http
    port: 80
    targetPort: 8080
    protocol: TCP
  - name: https
    port: 443
    targetPort: 8080
    protocol: TCP
"""

                    
                    // Write deployment manifest to file
                    writeFile file: 'k8s-deployment.yaml', text: deploymentYaml
                    
                    // Apply the deployment using kubectl with file credential
                    withCredentials([
                        file(credentialsId: 'KUBECONFIG_PATH', variable: 'KCFG')
                    ]) {
                        sh """
                            export KUBECONFIG="\$KCFG"
                            
                            # Verify kubectl can connect to the cluster
                            kubectl config get-contexts

                            # Force delete and recreate service to remove stale LoadBalancer annotations
                            echo "Force deleting any existing service with stale LoadBalancer annotations..."

                            # Force delete the existing service completely
                            echo "Deleting existing service: inventory-${params.TENANT_NAME}-service"
                            kubectl delete service inventory-${params.TENANT_NAME}-service -n ${k8sNamespace} --ignore-not-found=true

                            # Wait for complete deletion
                            echo "Waiting for service deletion to complete..."
                            sleep 10
                            
                            # Verify service is gone
                            if kubectl get service inventory-${params.TENANT_NAME}-service -n ${k8sNamespace} >/dev/null 2>&1; then
                                echo "Service still exists, waiting longer..."
                                sleep 20
                                
                                # Try force delete again if still exists
                                kubectl delete service inventory-${params.TENANT_NAME}-service -n ${k8sNamespace} --force --grace-period=0 || true
                                sleep 5
                            fi
                            
                            echo "Service cleanup completed, ready to create fresh service"
                            kubectl cluster-info
                            
                            # Check if the service account exists in the namespace
                            echo "DEBUG: k8sNamespace variable = ${k8sNamespace}"
                            echo "Checking for service account ${params.TENANT_NAME}-admin in namespace ${k8sNamespace}"
                            kubectl get serviceaccount ${params.TENANT_NAME}-admin -n ${k8sNamespace} || {
                                echo "ERROR: Service account ${params.TENANT_NAME}-admin not found in namespace ${k8sNamespace}"
                                echo "Available service accounts in namespace ${k8sNamespace}:"
                                kubectl get serviceaccounts -n ${k8sNamespace}
                                exit 1
                            }
                            
                            # Apply the deployment
                            kubectl apply -f k8s-deployment.yaml
                            kubectl rollout status deployment/inventory-${params.TENANT_NAME} -n ${k8sNamespace} --timeout=300s
                            
                            # LoadBalancer will be created by Jenkins job - no need to wait for external IP
                            echo "LoadBalancer service created successfully"
                            echo "DNS record will be created after LoadBalancer is provisioned"
                            # Verify the annotation details
                            echo "=== Verify the annotation details ==="
                            kubectl get svc inventory-${params.TENANT_NAME}-service -n ${k8sNamespace} -o yaml | grep -A4 annotations
                            
                            # Debug: Check service configuration and load balancer details
                            echo "=== Service Configuration ==="
                            kubectl get service inventory-${params.TENANT_NAME}-service -n ${k8sNamespace} -o yaml
                            
                            echo "=== Load Balancer ID ==="
                            LB_ID=\$(kubectl get service inventory-${params.TENANT_NAME}-service -n ${k8sNamespace} -o jsonpath='{.metadata.annotations.kubernetes\\.digitalocean\\.com/load-balancer-id}')
                            echo "Load Balancer ID: \$LB_ID"
                            
                            echo "=== Node Information ==="
                            kubectl get nodes -o wide
                            
                            echo "=== Pod Status ==="
                            kubectl get pods -n ${k8sNamespace} -o wide
                            
                        """
                    }
                }
            }
        }

        stage('LB: Discover IDs') {
            steps {
                withCredentials([ file(credentialsId: 'KUBECONFIG_PATH', variable: 'KCFG') ]) {
                    script {
                        // Get LoadBalancer ID
                        env.LB_ID = sh(
                            script: "export KUBECONFIG='${KCFG}'; kubectl get svc inventory-${params.TENANT_NAME}-service -n ${env.K8S_NAMESPACE} -o jsonpath='{.metadata.annotations.kubernetes\\.digitalocean\\.com/load-balancer-id}'",
                            returnStdout: true
                        ).trim()
                        if (!env.LB_ID) { error "LB_ID not found on service annotation" }

                        // Wait for external IP to be assigned (with timeout)
                        echo "Waiting for LoadBalancer external IP to be assigned..."
                        def maxAttempts = 60  // 10 minutes max wait
                        def attempt = 0
                        
                        while (attempt < maxAttempts) {
                            env.EXTERNAL_IP = sh(
                                script: "export KUBECONFIG='${KCFG}'; kubectl get svc inventory-${params.TENANT_NAME}-service -n ${env.K8S_NAMESPACE} -o jsonpath='{.status.loadBalancer.ingress[0].ip}'",
                                returnStdout: true
                            ).trim()
                            
                            if (env.EXTERNAL_IP && env.EXTERNAL_IP != 'null' && env.EXTERNAL_IP != '') {
                                echo "External IP assigned: ${env.EXTERNAL_IP}"
                                break
                            }
                            
                            attempt++
                            echo "Attempt ${attempt}/${maxAttempts}: External IP not ready yet, waiting 10 seconds..."
                            sleep(10)
                        }
                        
                        if (!env.EXTERNAL_IP || env.EXTERNAL_IP == 'null' || env.EXTERNAL_IP == '') { 
                            error "External IP not assigned after ${maxAttempts} attempts (${maxAttempts * 10} seconds)" 
                        }

                        echo "Found LB_ID: ${env.LB_ID}"
                        echo "Service IP : ${env.EXTERNAL_IP}"
                    }
                }
            }
        }

                stage('DNS: Ensure domain exists') {
            steps {
                withCredentials([ string(credentialsId: 'DO_API_TOKEN', variable: 'DO_API_TOKEN') ]) {
                    script {
                        echo "Checking if domain ${params.DO_DOMAIN} exists in DigitalOcean..."
                        
                        // Check if domain exists
                        def domainExists = sh(
                            script: 'curl -sS -H "Authorization: Bearer $DO_API_TOKEN" "https://api.digitalocean.com/v2/domains/' + params.DO_DOMAIN + '" | jq -r ".domain.name // empty"',
                            returnStdout: true
                        ).trim()
                        
                        if (domainExists == params.DO_DOMAIN) {
                            echo "Domain ${params.DO_DOMAIN} already exists in DigitalOcean"
                        } else {
                            echo "Domain ${params.DO_DOMAIN} not found, creating it..."
                            
                            def createResult = sh(
                                script: 'curl -sS -X POST -H "Content-Type: application/json" -H "Authorization: Bearer $DO_API_TOKEN" -d \'{"name":"' + params.DO_DOMAIN + '"}\' "https://api.digitalocean.com/v2/domains"',
                                returnStdout: true
                            ).trim()
                            
                            // Check if creation was successful
                            def createdDomain = sh(
                                script: 'echo \'' + createResult + '\' | jq -r ".domain.name // empty"',
                                returnStdout: true
                            ).trim()
                            
                            if (createdDomain == params.DO_DOMAIN) {
                                echo "Successfully created domain ${params.DO_DOMAIN} in DigitalOcean"
                                echo "Default DNS records created for the domain"
                            } else {
                                echo "Domain creation response: ${createResult}"
                                error "Failed to create domain ${params.DO_DOMAIN} in DigitalOcean"
                            }
                        }
                    }
                }
            }
        }

       stage('DNS: Ensure A record') {
            steps {
                withCredentials([ string(credentialsId: 'DO_API_TOKEN', variable: 'DO_API_TOKEN') ]) {
                    script {
                        // Get existing DNS records
                        def listRecords = sh(
                            script: 'curl -sS -H "Authorization: Bearer $DO_API_TOKEN" "https://api.digitalocean.com/v2/domains/' + params.DO_DOMAIN + '/records"',
                            returnStdout: true
                        ).trim()
                        
                        // Check if A record already exists for this tenant
                        def existingRecordId = sh(
                            script: 'echo \'' + listRecords + '\' | jq -r --arg name "' + params.TENANT_NAME + '" \'(.domain_records // []) | map(select(.type=="A" and .name==$name)) | (.[0].id // empty)\'',
                            returnStdout: true
                        ).trim()
                        
                        if (existingRecordId && existingRecordId != '' && existingRecordId != 'null') {
                            echo "Found existing A record with ID: ${existingRecordId}"
                            
                            // Get current IP of existing record
                            def currentIp = sh(
                                script: 'echo \'' + listRecords + '\' | jq -r --arg id "' + existingRecordId + '" \'(.domain_records // []) | map(select((.id|tostring)==$id)) | (.[0].data // "")\'',
                                returnStdout: true
                            ).trim()
                            
                            if (currentIp != env.EXTERNAL_IP) {
                                echo "Updating A record from ${currentIp} to ${env.EXTERNAL_IP}"
                                sh 'curl -sS -X PUT -H "Content-Type: application/json" -H "Authorization: Bearer $DO_API_TOKEN" -d \'{"data":"' + env.EXTERNAL_IP + '"}\' "https://api.digitalocean.com/v2/domains/' + params.DO_DOMAIN + '/records/' + existingRecordId + '"'
                            } else {
                                echo "A record already points to correct IP: ${env.EXTERNAL_IP}"
                            }
                        } else {
                            echo "Creating new A record for ${params.TENANT_NAME}.${params.DO_DOMAIN} -> ${env.EXTERNAL_IP}"
                            sh 'curl -sS -X POST -H "Content-Type: application/json" -H "Authorization: Bearer $DO_API_TOKEN" -d \'{"type":"A","name":"' + params.TENANT_NAME + '","data":"' + env.EXTERNAL_IP + '","ttl":60}\' "https://api.digitalocean.com/v2/domains/' + params.DO_DOMAIN + '/records"'
                        }
                        
                        echo "DNS A record operation completed"
                    }
                }
            }
        }

        stage('DNS: Wait for resolution') {
            steps {
                script {
                    withEnv([
                        "FQDN=${params.TENANT_NAME}.${params.DO_DOMAIN}",
                        "IP=${env.EXTERNAL_IP}"
                    ]) {
                        sh '''#!/bin/bash
                            set -euo pipefail
                            FQDN="$FQDN"
                            IP="$IP"

                            resolve() {
                                if command -v dig >/dev/null 2>&1; then
                                    dig +short A "$FQDN" | sed '/^$/d' | sort -u
                                else
                                    getent ahostsv4 "$FQDN" 2>/dev/null | awk '{print $1}' | sort -u
                                fi
                            }

                            for i in $(seq 1 60); do
                                RES="$(resolve || true)"
                                echo "Resolved for $FQDN: $RES"
                                if printf '%s\n' "$RES" | grep -Fx "$IP" >/dev/null; then
                                    echo "DNS OK: $FQDN -> $IP"
                                    exit 0
                                fi
                                sleep 5
                            done

                            echo "DNS not pointing yet to $IP for $FQDN"
                            exit 1
                        '''
                    }
                }
            }
        }

       stage('Cert: Ensure managed cert') {
            steps {
                withCredentials([ string(credentialsId: 'DO_API_TOKEN', variable: 'DO_API_TOKEN') ]) {
                    script {
                        def fqdn = "${params.TENANT_NAME}.${params.DO_DOMAIN}"
                        echo "Ensuring DO managed cert for: ${fqdn}"

                        // Get existing certificates
                        def certsJson = sh(
                            script: 'curl -sS -H "Authorization: Bearer $DO_API_TOKEN" "https://api.digitalocean.com/v2/certificates"',
                            returnStdout: true
                        ).trim()

                        // Check for existing certificate for this FQDN
                        def existingCertId = sh(
                            script: 'echo \'' + certsJson + '\' | jq -r --arg fq "' + fqdn + '" \'(.certificates // []) | map(select((.dns_names // []) | index($fq))) | (.[0].id // empty)\'',
                            returnStdout: true
                        ).trim()

                        if (!existingCertId || existingCertId == '' || existingCertId == 'null') {
                            // Check for wildcard certificate
                            def wildcardDomain = "*." + params.DO_DOMAIN
                            existingCertId = sh(
                                script: 'echo \'' + certsJson + '\' | jq -r --arg wc "' + wildcardDomain + '" \'(.certificates // []) | map(select((.dns_names // []) | index($wc))) | (.[0].id // empty)\'',
                                returnStdout: true
                            ).trim()
                        }

                        if (existingCertId && existingCertId != '' && existingCertId != 'null') {
                            echo "Found existing certificate with ID: ${existingCertId}"
                            env.CERT_ID = existingCertId
                        } else {
                            echo "No existing certificate found, creating new Let's Encrypt certificate for ${fqdn}"
                            
                            // Create new certificate
                            def createResult = sh(
                                script: 'curl -sS -X POST -H "Content-Type: application/json" -H "Authorization: Bearer $DO_API_TOKEN" -d \'{"name":"' + fqdn + '","type":"lets_encrypt","dns_names":["' + fqdn + '"]}\' "https://api.digitalocean.com/v2/certificates"',
                                returnStdout: true
                            ).trim()

                            // Extract certificate ID from creation response
                            def newCertId = sh(
                                script: 'echo \'' + createResult + '\' | jq -r \'.certificate.id // .id // empty\'',
                                returnStdout: true
                            ).trim()

                            if (newCertId && newCertId != '' && newCertId != 'null') {
                                echo "Certificate creation initiated with ID: ${newCertId}"
                                
                                // Wait for certificate to be issued (max 6 minutes)
                                def maxAttempts = 36
                                def attempt = 0
                                def certState = 'unknown'
                                
                                while (attempt < maxAttempts) {
                                    sleep(10)
                                    attempt++
                                    
                                    def stateResult = sh(
                                        script: 'curl -sS -H "Authorization: Bearer $DO_API_TOKEN" "https://api.digitalocean.com/v2/certificates/' + newCertId + '"',
                                        returnStdout: true
                                    ).trim()
                                    
                                    certState = sh(
                                        script: 'echo \'' + stateResult + '\' | jq -r \'.certificate.state // .state // "unknown"\'',
                                        returnStdout: true
                                    ).trim()
                                    
                                    echo "Certificate state check ${attempt}/${maxAttempts}: ${certState}"
                                    
                                    if (certState == 'verified') {
                                        echo "Certificate successfully issued!"
                                        env.CERT_ID = newCertId
                                        break
                                    } else if (certState == 'error') {
                                        echo "Certificate issuance failed"
                                        break
                                    }
                                }
                                
                                if (certState != 'verified') {
                                    error "Certificate failed to be issued after ${maxAttempts} attempts (6 minutes). State: ${certState}"
                                }
                            } else {
                                echo "Certificate creation response: ${createResult}"
                                error "Failed to create certificate for ${fqdn}"
                            }
                        }

                        if (!env.CERT_ID) {
                            error "Could not find or issue a DigitalOcean certificate for ${fqdn}"
                        }
                        
                        echo "Using certificate ID: ${env.CERT_ID}"
                    }
                }
            }
        }

        stage('Service: Attach cert & redirect') {
            steps {
                script {
                    withEnv([
                        "TENANT=${params.TENANT_NAME}",
                        "KNS=${env.K8S_NAMESPACE}"
                    ]) {
                        sh '''
                            export KUBECONFIG="$KCFG"
                            kubectl annotate svc inventory-"$TENANT"-service \
                                -n "$KNS" \
                                service.beta.kubernetes.io/do-loadbalancer-certificate-id="${CERT_ID}" \
                                --overwrite

                            kubectl annotate svc inventory-"$TENANT"-service \
                                -n "$KNS" \
                                service.beta.kubernetes.io/do-loadbalancer-redirect-http-to-https="true" \
                                --overwrite

                            kubectl annotate svc inventory-"$TENANT"-service \
                                -n "$KNS" \
                                service.beta.kubernetes.io/do-loadbalancer-tls-passthrough="false" \
                                --overwrite

                            kubectl annotate svc inventory-"$TENANT"-service \
                                -n "$KNS" \
                                service.beta.kubernetes.io/do-loadbalancer-tls-ports="443" \
                                --overwrite
                        '''
                    }
                    echo "Certificate attached and HTTPS redirect enabled."
                }
            }
        }
    } // End of stages block

    post {
        success {
            echo "Deployment completed successfully for tenant: ${params.TENANT_NAME}"
            echo "Docker image: ${env.DOCKER_IMAGE}"
            script {
                def k8sNamespace = params.K8S_NAMESPACE ?: "tenant-${params.TENANT_NAME.toLowerCase().replaceAll('[^a-z0-9-]', '-')}"
                echo "Kubernetes namespace: ${k8sNamespace}"
            }
        }
        failure {
            echo "Deployment failed for tenant: ${params.TENANT_NAME}"
        }
        always {
            // Clean up temporary files
            sh 'rm -f Dockerfile k8s-deployment.yaml'
        }
    }
}
