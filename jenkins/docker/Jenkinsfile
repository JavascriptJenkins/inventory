pipeline {
    agent any

    tools {
        maven 'maven3'
    }

    parameters {
        // Build parameters
        string(name: 'BRANCH', defaultValue: 'test1', description: 'Branch to build from')
        string(name: 'TENANT_NAME', defaultValue: '', description: 'Tenant name for deployment')
        string(name: 'APP_NAME', defaultValue: 'inventory', description: 'Application name')
        string(name: 'SUBSCRIPTION_TIER', defaultValue: 'BASIC', description: 'Subscription tier')
        string(name: 'BILLING_EMAIL', defaultValue: '', description: 'Billing email address')
        string(name: 'K8S_NAMESPACE', defaultValue: '', description: 'Kubernetes namespace (auto-generated if empty)')

        // DigitalOcean parameters
        string(name: 'DO_LOADBALANCER_ID', defaultValue: '', description: 'DigitalOcean Load Balancer ID for Kubernetes Service annotation')
        
        // Docker parameters
        string(name: 'DOCKER_USER', defaultValue: 'techvvsadmin', description: 'Docker Hub username')
        
                 // Application configuration parameters
         string(name: 'ENVIRONMENT_NAME', defaultValue: 'prod', description: 'Environment name (prod, dev1)')
         string(name: 'LOAD_REF_DATA', defaultValue: 'no', description: 'Load reference data (yes/no)')
         string(name: 'TAX_PERCENTAGE', defaultValue: '0', description: 'Tax percentage')
         string(name: 'MAX_FILE_SIZE', defaultValue: '500MB', description: 'Maximum file size')
        string(name: 'MAX_REQ_SIZE', defaultValue: '500MB', description: 'Maximum request size')
        
        // Database configuration
        string(name: 'DB_DRIVER_CLASS_NAME', defaultValue: 'org.postgresql.Driver', description: 'Database driver class')
        string(name: 'DB_JPA_DATABASE_PLATFORM', defaultValue: 'org.hibernate.dialect.PostgreSQLDialect', description: 'JPA database platform')
        string(name: 'DB_JPA_HIBERNATE_DIALECT', defaultValue: 'org.hibernate.dialect.PostgreSQLDialect', description: 'Hibernate dialect')
        string(name: 'DB_USERNAME', defaultValue: 'doadmin', description: 'Database username')
        string(name: 'SANDBOX_POSTGRESQL_URI', defaultValue: 'jdbc:postgresql://private-sandbox-cluster-do-user-1326368-0.e.db.ondigitalocean.com:25060', description: 'Database uri')
        string(name: 'DB_URI', defaultValue: 'jdbc:postgresql://private-sandbox-cluster-do-user-1326368-0.e.db.ondigitalocean.com:25060', description: 'Database uri')
        string(name: 'SPRING_DATABASE_ACTION', defaultValue: 'update', description: 'Database action (update, create-drop)')
        string(name: 'DB_H2_CONSOLE_ENABLED', defaultValue: 'false', description: 'Enable H2 console')
        string(name: 'DB_H2_WEB_ALLOWOTHERS', defaultValue: 'false', description: 'Allow others to access H2 console')
        
        // PayPal configuration
        string(name: 'PAYPAL_ENVIRONMENT', defaultValue: 'SANDBOX', description: 'PayPal environment (SANDBOX/PRODUCTION)')
        string(name: 'PAYPAL_BRAND_NAME', defaultValue: 'techvvs_clothing_app_1', description: 'PayPal brand name')
        
        // Wallet configuration
        string(name: 'WALLET_BRAND', defaultValue: 'Tulip', description: 'Wallet brand organization name')
        string(name: 'WALLET_BRAND_PROGRAM', defaultValue: 'Tulip Membership', description: 'Wallet brand program name')
        string(name: 'WALLET_GOOGLE_SERVICE_ACC_KEY_PATH', defaultValue: 'classpath:/uploads/applecert/', description: 'Google service account key path')
        string(name: 'WALLET_GOOGLE_ISSUER_ID', defaultValue: '', description: 'Google wallet issuer ID')
        string(name: 'WALLET_GOOGLE_CLASS_ID', defaultValue: '', description: 'Google wallet class ID')
        
                 // METRC configuration
         string(name: 'METRC_MCP_FILE_PATH', defaultValue: 'classpath:/uploads/mcp/metrc-mcp-connector.dxt', description: 'METRC MCP file path')
        
        // Request logging configuration
        string(name: 'REQUEST_LOGGING_ENABLED', defaultValue: 'true', description: 'Enable request logging')
        string(name: 'REQUEST_LOGGING_HEADERS', defaultValue: 'true', description: 'Log request headers')
        string(name: 'REQUEST_LOGGING_DEVICE_INFO', defaultValue: 'true', description: 'Log device info')
        string(name: 'REQUEST_LOGGING_SESSION_INFO', defaultValue: 'true', description: 'Log session info')
        string(name: 'REQUEST_LOGGING_SECURITY_INFO', defaultValue: 'false', description: 'Log security info')
    }

    stages {
        stage('Checkout') {
            steps {
                checkout([
                    $class: 'GitSCM',
                    branches: [[name: "*/${params.BRANCH}"]],
                    userRemoteConfigs: [[url: 'https://github.com/javascriptjenkins/inventory.git', credentialsId: 'githubcreds']]
                ])
            }
        }



        stage('Log Build Parameters') {
            steps {
                script {
                    echo "=========================================="
                    echo "JENKINS BUILD PARAMETERS LOG"
                    echo "=========================================="
                    echo ""
                    
                    echo "üìã BUILD PARAMETERS:"
                    echo "  BRANCH: ${params.BRANCH}"
                    echo "  TENANT_NAME: ${params.TENANT_NAME}"
                    echo "  APP_NAME: ${params.APP_NAME}"
                    echo "  SUBSCRIPTION_TIER: ${params.SUBSCRIPTION_TIER}"
                    echo "  BILLING_EMAIL: ${params.BILLING_EMAIL}"
                    echo "  K8S_NAMESPACE: ${params.K8S_NAMESPACE}"
                    
                    echo "üåê DIGITALOCEAN PARAMETERS:"
                    echo "  DO_LOADBALANCER_ID: ${params.DO_LOADBALANCER_ID}"
                    echo ""
                    
                    echo "üê≥ DOCKER PARAMETERS:"
                    echo "  DOCKER_USER: ${params.DOCKER_USER}"
                    echo ""
                    
                    echo "‚öôÔ∏è APPLICATION CONFIGURATION:"
                    echo "  ENVIRONMENT_NAME: ${params.ENVIRONMENT_NAME}"
                    echo "  LOAD_REF_DATA: ${params.LOAD_REF_DATA}"
                    echo "  TAX_PERCENTAGE: ${params.TAX_PERCENTAGE}"
                    echo "  MAX_FILE_SIZE: ${params.MAX_FILE_SIZE}"
                    echo "  MAX_REQ_SIZE: ${params.MAX_REQ_SIZE}"
                    echo ""
                    
                    echo "üóÑÔ∏è DATABASE CONFIGURATION:"
                    echo "  DB_DRIVER_CLASS_NAME: ${params.DB_DRIVER_CLASS_NAME}"
                    echo "  DB_JPA_DATABASE_PLATFORM: ${params.DB_JPA_DATABASE_PLATFORM}"
                    echo "  DB_JPA_HIBERNATE_DIALECT: ${params.DB_JPA_HIBERNATE_DIALECT}"
                    echo "  DB_USERNAME: ${params.DB_USERNAME}"
                    echo "  SANDBOX_POSTGRESQL_URI: ${params.SANDBOX_POSTGRESQL_URI}"
                    echo "  env.DB_URI: ${env.DB_URI}"
                    echo "  SPRING_DATABASE_ACTION: ${params.SPRING_DATABASE_ACTION}"
                    echo "  DB_H2_CONSOLE_ENABLED: ${params.DB_H2_CONSOLE_ENABLED}"
                    echo "  DB_H2_WEB_ALLOWOTHERS: ${params.DB_H2_WEB_ALLOWOTHERS}"
                    echo ""
                    
                    echo "üí≥ PAYPAL CONFIGURATION:"
                    echo "  PAYPAL_ENVIRONMENT: ${params.PAYPAL_ENVIRONMENT}"
                    echo "  PAYPAL_BRAND_NAME: ${params.PAYPAL_BRAND_NAME}"
                    echo ""
                    
                    echo "üëõ WALLET CONFIGURATION:"
                    echo "  WALLET_BRAND: ${params.WALLET_BRAND}"
                    echo "  WALLET_BRAND_PROGRAM: ${params.WALLET_BRAND_PROGRAM}"
                    echo "  WALLET_GOOGLE_SERVICE_ACC_KEY_PATH: ${params.WALLET_GOOGLE_SERVICE_ACC_KEY_PATH}"
                    echo "  WALLET_GOOGLE_ISSUER_ID: ${params.WALLET_GOOGLE_ISSUER_ID}"
                    echo "  WALLET_GOOGLE_CLASS_ID: ${params.WALLET_GOOGLE_CLASS_ID}"
                    echo ""
                    
                    echo "üåø METRC CONFIGURATION:"
                    echo "  METRC_MCP_FILE_PATH: ${params.METRC_MCP_FILE_PATH}"
                    echo ""
                    
                    echo "üìä REQUEST LOGGING CONFIGURATION:"
                    echo "  REQUEST_LOGGING_ENABLED: ${params.REQUEST_LOGGING_ENABLED}"
                    echo "  REQUEST_LOGGING_HEADERS: ${params.REQUEST_LOGGING_HEADERS}"
                    echo "  REQUEST_LOGGING_DEVICE_INFO: ${params.REQUEST_LOGGING_DEVICE_INFO}"
                    echo "  REQUEST_LOGGING_SESSION_INFO: ${params.REQUEST_LOGGING_SESSION_INFO}"
                    echo "  REQUEST_LOGGING_SECURITY_INFO: ${params.REQUEST_LOGGING_SECURITY_INFO}"
                    echo ""
                    
                    echo "=========================================="
                    echo "END OF BUILD PARAMETERS LOG"
                    echo "=========================================="
                }
            }
        }

        stage('Update Application Properties') {
            steps {
                script {
                    withCredentials([
                        // API Keys and Secrets
                        string(credentialsId: 'TWILIO_API_USER', variable: 'TWILIO_API_USER'),
                        string(credentialsId: 'TWILIO_API_PASSWORD', variable: 'TWILIO_API_PASSWORD'),
                        string(credentialsId: 'SENDGRID_API_KEY', variable: 'SENDGRID_API_KEY'),
                        string(credentialsId: 'JWT_SECRET_KEY', variable: 'JWT_SECRET_KEY'),
                        string(credentialsId: 'METRC_API_KEY_USERNAME', variable: 'METRC_API_KEY_USERNAME'),
                        string(credentialsId: 'METRC_API_KEY_PASSWORD', variable: 'METRC_API_KEY_PASSWORD'),
                        string(credentialsId: 'PAYPAL_CLIENT_ID', variable: 'PAYPAL_CLIENT_ID'),
                        string(credentialsId: 'PAYPAL_CLIENT_SECRET', variable: 'PAYPAL_CLIENT_SECRET'),
                        string(credentialsId: 'ANTHROPIC_API_KEY', variable: 'ANTHROPIC_API_KEY'),
                        
                        // Database credentials
                        string(credentialsId: 'DB_PASSWORD', variable: 'DB_PASSWORD'),
                        string(credentialsId: 'POSTGRE_TEST_DB_PASSWORD', variable: 'POSTGRE_TEST_DB_PASSWORD'),
                        string(credentialsId: 'POSTGRE_PROD_DB_PASSWORD', variable: 'POSTGRE_PROD_DB_PASSWORD'),
                        string(credentialsId: 'POSTGRE_ALPHA_DB_PASSWORD', variable: 'POSTGRE_ALPHA_DB_PASSWORD'),
                        
                        // Digital Ocean credentials
                        string(credentialsId: 'DO_API_TOKEN', variable: 'DO_API_TOKEN'),
                        string(credentialsId: 'DO_DOMAIN', variable: 'DO_DOMAIN'),
                        string(credentialsId: 'DO_LB_IP', variable: 'DO_LB_IP'),
                        string(credentialsId: 'SANDBOX_POSTGRESQL_PUBLIC_USER', variable: 'SANDBOX_POSTGRESQL_PUBLIC_USER'),
                        string(credentialsId: 'SANDBOX_POSTGRESQL_PUBLIC_URI', variable: 'SANDBOX_POSTGRESQL_PUBLIC_URI'),
                        string(credentialsId: 'SANDBOX_POSTGRESQL_PASSWORD', variable: 'SANDBOX_POSTGRESQL_PASSWORD'),
                        
                        // Jenkins credentials
                        string(credentialsId: 'JENKINS_USERNAME', variable: 'JENKINS_USERNAME'),
                        string(credentialsId: 'JENKINS_API_TOKEN', variable: 'JENKINS_API_TOKEN'),

                        // Kubernetes config file
                        file(credentialsId: 'KUBECONFIG_PATH', variable: 'KUBECONFIG_FILE')
                    ]) {
                        // Log credentials being used (without exposing actual values)
                        echo "=========================================="
                        echo "CREDENTIALS BEING USED (IDs only for security)"
                        echo "=========================================="
                        echo ""
                        
                        echo "üîê API KEYS AND SECRETS:"
                        echo "  TWILIO_API_USER: [CREDENTIAL ID: TWILIO_API_USER]"
                        echo "  TWILIO_API_PASSWORD: [CREDENTIAL ID: TWILIO_API_PASSWORD]"
                        echo "  SENDGRID_API_KEY: [CREDENTIAL ID: SENDGRID_API_KEY]"
                        echo "  JWT_SECRET_KEY: [CREDENTIAL ID: JWT_SECRET_KEY]"
                        echo "  METRC_API_KEY_USERNAME: [CREDENTIAL ID: METRC_API_KEY_USERNAME]"
                        echo "  METRC_API_KEY_PASSWORD: [CREDENTIAL ID: METRC_API_KEY_PASSWORD]"
                        echo "  PAYPAL_CLIENT_ID: [CREDENTIAL ID: PAYPAL_CLIENT_ID]"
                        echo "  PAYPAL_CLIENT_SECRET: [CREDENTIAL ID: PAYPAL_CLIENT_SECRET]"
                        echo "  ANTHROPIC_API_KEY: [CREDENTIAL ID: ANTHROPIC_API_KEY]"
                        echo ""
                        
                        echo "üóÑÔ∏è DATABASE CREDENTIALS:"
                        echo "  DB_PASSWORD: [CREDENTIAL ID: DB_PASSWORD]"
                        echo "  POSTGRE_TEST_DB_PASSWORD: [CREDENTIAL ID: POSTGRE_TEST_DB_PASSWORD]"
                        echo "  POSTGRE_PROD_DB_PASSWORD: [CREDENTIAL ID: POSTGRE_PROD_DB_PASSWORD]"
                        echo "  POSTGRE_ALPHA_DB_PASSWORD: [CREDENTIAL ID: POSTGRE_ALPHA_DB_PASSWORD]"
                        echo "  SANDBOX_POSTGRESQL_PUBLIC_USER: [CREDENTIAL ID: SANDBOX_POSTGRESQL_PUBLIC_USER]"
                        echo "  SANDBOX_POSTGRESQL_PUBLIC_URI: [CREDENTIAL ID: SANDBOX_POSTGRESQL_PUBLIC_URI]"
                        echo "  SANDBOX_POSTGRESQL_PASSWORD: [CREDENTIAL ID: SANDBOX_POSTGRESQL_PASSWORD]"
                        echo ""
                        
                        echo "üåê DIGITALOCEAN CREDENTIALS:"
                        echo "  DO_API_TOKEN: [CREDENTIAL ID: DO_API_TOKEN]"
                        echo "  DO_DOMAIN: [CREDENTIAL ID: DO_DOMAIN]"
                        echo "  DO_LB_IP: [CREDENTIAL ID: DO_LB_IP]"
                        echo ""
                        
                        echo "üîß JENKINS CREDENTIALS:"
                        echo "  JENKINS_USERNAME: [CREDENTIAL ID: JENKINS_USERNAME]"
                        echo "  JENKINS_API_TOKEN: [CREDENTIAL ID: JENKINS_API_TOKEN]"
                        echo ""
                        
                        echo "‚ò∏Ô∏è KUBERNETES CONFIGURATION:"
                        echo "  KUBECONFIG_PATH: [CREDENTIAL ID: KUBECONFIG_PATH]"
                        echo ""
                        
                        echo "=========================================="
                        echo "END OF CREDENTIALS LOG"
                        echo "=========================================="
                        
                        dir('inventory') {
                            // Copy kubeconfig to a writable location and update the path in application.properties
               // Create kubeconfig from string content
         sh "mkdir -p kubeconfig"
         sh "cp ${KUBECONFIG_FILE} kubeconfig/tulip-sandbox-kubeconfig.yaml"
         sh "chmod 600 kubeconfig/tulip-sandbox-kubeconfig.yaml"


                             // Construct BASE_QR_DOMAIN from tenant name and DO domain
                             def baseQrDomain = "https://${params.TENANT_NAME}.${DO_DOMAIN}"
                             echo "Constructed BASE_QR_DOMAIN: ${baseQrDomain}"
                             
                             // Construct Kubernetes namespace from tenant name (same logic as Java code)
                             def k8sNamespace = params.K8S_NAMESPACE ?: "tenant-${params.TENANT_NAME.toLowerCase().replaceAll('[^a-z0-9-]', '-')}"
                             echo "Using Kubernetes namespace: ${k8sNamespace}"
                             
                             // Log all dynamic values being used
                             echo "=========================================="
                             echo "DYNAMIC VALUES CALCULATED DURING BUILD"
                             echo "=========================================="
                             echo ""
                             echo "üåê DYNAMIC DOMAIN CONFIGURATION:"
                             echo "  BASE_QR_DOMAIN: ${baseQrDomain}"
                             echo "  METRC_MCP_URI: ${baseQrDomain}/api/mcp"
                             echo ""
                             echo "‚ò∏Ô∏è KUBERNETES CONFIGURATION:"
                             echo "  K8S_NAMESPACE: ${k8sNamespace}"
                             echo ""
                             echo "=========================================="
                             echo "END OF DYNAMIC VALUES LOG"
                             echo "=========================================="
                             
                             // Update application.properties with all parameters
                             // Basic application settings
                             if (params.ENVIRONMENT_NAME) {
                                 sh "sed -i 's/^spring\\.profiles\\.active=.*/spring.profiles.active=${params.ENVIRONMENT_NAME}/' src/main/resources/application.properties"
                             }
                             if (params.LOAD_REF_DATA) {
                                 sh "sed -i 's/^load\\.ref\\.data=.*/load.ref.data=${params.LOAD_REF_DATA}/' src/main/resources/application.properties"
                             }
                             if (params.TAX_PERCENTAGE) {
                                 sh "sed -i 's/^tax\\.percentage=.*/tax.percentage=${params.TAX_PERCENTAGE}/' src/main/resources/application.properties"
                             }
                             sh "sed -i 's|^base\\.qr\\.domain=.*|base.qr.domain=${baseQrDomain}|' src/main/resources/application.properties"
                             if (params.MAX_FILE_SIZE) {
                                 sh "sed -i 's/^spring\\.servlet\\.multipart\\.max-file-size=.*/spring.servlet.multipart.max-file-size=${params.MAX_FILE_SIZE}/' src/main/resources/application.properties"
                             }
                             if (params.MAX_REQ_SIZE) {
                                 sh "sed -i 's/^spring\\.servlet\\.multipart\\.max-request-size=.*/spring.servlet.multipart.max-request-size=${params.MAX_REQ_SIZE}/' src/main/resources/application.properties"
                             }
                             
                             // Database settings
                             sh "sed -i 's|^spring\\.datasource\\.url=.*|spring.datasource.url=${params.DB_URI}/defaultdb?currentSchema=tenant_${params.TENANT_NAME}&sslmode=require|' src/main/resources/application.properties"
                             sh "echo 'Updated DB_URI: ${params.DB_URI}/defaultdb?currentSchema=tenant_${params.TENANT_NAME}&sslmode=require'"
                             if (params.DB_DRIVER_CLASS_NAME) {
                                 sh "sed -i 's/^spring\\.datasource\\.driver-class-name=.*/spring.datasource.driver-class-name=${params.DB_DRIVER_CLASS_NAME}/' src/main/resources/application.properties"
                             }
                             if (params.DB_JPA_DATABASE_PLATFORM) {
                                 sh "sed -i 's/^spring\\.jpa\\.database-platform=.*/spring.jpa.database-platform=${params.DB_JPA_DATABASE_PLATFORM}/' src/main/resources/application.properties"
                             }
                             if (params.DB_JPA_HIBERNATE_DIALECT) {
                                 sh "sed -i 's/^spring\\.jpa\\.properties\\.hibernate\\.dialect=.*/spring.jpa.properties.hibernate.dialect=${params.DB_JPA_HIBERNATE_DIALECT}/' src/main/resources/application.properties"
                             }
                            sh "sed -i 's/^spring\\.datasource\\.username=.*/spring.datasource.username=${SANDBOX_POSTGRESQL_PUBLIC_USER}/' src/main/resources/application.properties"
                            sh "sed -i 's/^spring\\.datasource\\.password=.*/spring.datasource.password=${SANDBOX_POSTGRESQL_PASSWORD}/' src/main/resources/application.properties"
                            sh "sed -i 's/^spring\\.jpa\\.properties\\.hibernate\\.default_schema=.*/spring.jpa.properties.hibernate.default_schema=${params.TENANT_NAME}/' src/main/resources/application.properties"

                             if (params.SPRING_DATABASE_ACTION) {
                                 sh "sed -i 's/^spring\\.jpa\\.hibernate\\.ddl-auto=.*/spring.jpa.hibernate.ddl-auto=${params.SPRING_DATABASE_ACTION}/' src/main/resources/application.properties"
                             }
                             if (params.DB_H2_CONSOLE_ENABLED) {
                                 sh "sed -i 's/^spring\\.h2\\.console\\.enabled=.*/spring.h2.console.enabled=${params.DB_H2_CONSOLE_ENABLED}/' src/main/resources/application.properties"
                             }
                             if (params.DB_H2_WEB_ALLOWOTHERS) {
                                 sh "sed -i 's/^spring\\.h2\\.console\\.settings\\.web-allow-others=.*/spring.h2.console.settings.web-allow-others=${params.DB_H2_WEB_ALLOWOTHERS}/' src/main/resources/application.properties"
                             }
                             
                             // API Keys and Secrets
                             sh "sed -i 's|^twilio\\.api\\.username=.*|twilio.api.username=${TWILIO_API_USER}|' src/main/resources/application.properties"
                             sh "sed -i 's|^twilio\\.api\\.password=.*|twilio.api.password=${TWILIO_API_PASSWORD}|' src/main/resources/application.properties"
                             sh "sed -i 's|^sendgrid\\.api\\.key=.*|sendgrid.api.key=${SENDGRID_API_KEY}|' src/main/resources/application.properties"
                             sh "sed -i 's|^security\\.jwt\\.token\\.secret-key=.*|security.jwt.token.secret-key=${JWT_SECRET_KEY}|' src/main/resources/application.properties"
                             sh "sed -i 's|^metrc\\.api-key-username=.*|metrc.api-key-username=${METRC_API_KEY_USERNAME}|' src/main/resources/application.properties"
                             sh "sed -i 's|^metrc\\.api-key-password=.*|metrc.api-key-password=${METRC_API_KEY_PASSWORD}|' src/main/resources/application.properties"
                             sh "sed -i 's|^paypal\\.client-id=.*|paypal.client-id=${PAYPAL_CLIENT_ID}|' src/main/resources/application.properties"
                             sh "sed -i 's|^paypal\\.client-secret=.*|paypal.client-secret=${PAYPAL_CLIENT_SECRET}|' src/main/resources/application.properties"
                             sh "sed -i 's|^anthropic\\.apiKey=.*|anthropic.apiKey=${ANTHROPIC_API_KEY}|' src/main/resources/application.properties"
                             
                             // PayPal configuration
                             if (params.PAYPAL_ENVIRONMENT) {
                                 sh "sed -i 's/^paypal\\.environment=.*/paypal.environment=${params.PAYPAL_ENVIRONMENT}/' src/main/resources/application.properties"
                             }
                             if (params.PAYPAL_BRAND_NAME) {
                                 sh "sed -i 's/^paypal\\.brand-name=.*/paypal.brand-name=${params.PAYPAL_BRAND_NAME}/' src/main/resources/application.properties"
                             }
                             
                             // Wallet configuration
                             if (params.WALLET_BRAND) {
                                 sh "sed -i 's/^wallet\\.brand\\.organizationName=.*/wallet.brand.organizationName=${params.WALLET_BRAND}/' src/main/resources/application.properties"
                             }
                             if (params.WALLET_BRAND_PROGRAM) {
                                 sh "sed -i 's/^wallet\\.brand\\.programName=.*/wallet.brand.programName=${params.WALLET_BRAND_PROGRAM}/' src/main/resources/application.properties"
                             }
                             if (params.WALLET_GOOGLE_SERVICE_ACC_KEY_PATH) {
                                 sh "sed -i 's|^wallet\\.google\\.serviceAccountKeyPath=.*|wallet.google.serviceAccountKeyPath=${params.WALLET_GOOGLE_SERVICE_ACC_KEY_PATH}|' src/main/resources/application.properties"
                             }
                             if (params.WALLET_GOOGLE_ISSUER_ID) {
                                 sh "sed -i 's/^wallet\\.google\\.issuerId=.*/wallet.google.issuerId=${params.WALLET_GOOGLE_ISSUER_ID}/' src/main/resources/application.properties"
                             }
                             if (params.WALLET_GOOGLE_CLASS_ID) {
                                 sh "sed -i 's/^wallet\\.google\\.classId=.*/wallet.google.classId=${params.WALLET_GOOGLE_CLASS_ID}/' src/main/resources/application.properties"
                             }
                             
                             // METRC configuration
                             if (params.METRC_MCP_FILE_PATH) {
                                 sh "sed -i 's|^metrc\\.mcp\\.dxtPath=.*|metrc.mcp.dxtPath=${params.METRC_MCP_FILE_PATH}|' src/main/resources/application.properties"
                             }
                             sh "sed -i 's|^metrc\\.mcp\\.url=.*|metrc.mcp.url=${baseQrDomain}/api/mcp|' src/main/resources/application.properties"
                             
                             // Digital Ocean configuration
                             sh "sed -i 's|^digitalocean\\.api\\.token=.*|digitalocean.api.token=${DO_API_TOKEN}|' src/main/resources/application.properties"
                             sh "sed -i 's|^digitalocean\\.domain=.*|digitalocean.domain=${DO_DOMAIN}|' src/main/resources/application.properties"
                             sh "sed -i 's|^digitalocean\\.target\\.loadbalancer=.*|digitalocean.target.loadbalancer=${DO_LB_IP}|' src/main/resources/application.properties"
                             sh "sed -i 's|^digitalocean\\.postgresql\\.username=.*|digitalocean.postgresql.username=${SANDBOX_POSTGRESQL_PUBLIC_USER}|' src/main/resources/application.properties"
                             sh "sed -i 's|^digitalocean\\.postgresql\\.password=.*|digitalocean.postgresql.password=${SANDBOX_POSTGRESQL_PASSWORD}|' src/main/resources/application.properties"
                             sh "sed -i 's|^digitalocean\\.postgresql\\.uri=.*|digitalocean.postgresql.uri=${SANDBOX_POSTGRESQL_PUBLIC_URI}|' src/main/resources/application.properties"
                             
                             // Jenkins configuration
                             sh "sed -i 's|^jenkins\\.username=.*|jenkins.username=${JENKINS_USERNAME}|' src/main/resources/application.properties"
                             sh "sed -i 's|^jenkins\\.token=.*|jenkins.token=${JENKINS_API_TOKEN}|' src/main/resources/application.properties"
                             
                             // Update kubeconfig path to point to the copied file
                            echo "Updating kubernetes.kubeconfig.path to: file:/app/kubeconfig/tulip-sandbox-kubeconfig.yaml"

                             sh "sed -i 's|^kubernetes\\.kubeconfig\\.path=.*|kubernetes.kubeconfig.path=file:/app/kubeconfig/tulip-sandbox-kubeconfig.yaml|' src/main/resources/application.properties"
                             
                             // Verify the kubeconfig file exists
                             sh """
                                 if [ -f "kubeconfig/tulip-sandbox-kubeconfig.yaml" ]; then
                                     echo "Kubeconfig file verified: kubeconfig/tulip-sandbox-kubeconfig.yaml"
                                 else
                                     echo "ERROR: Kubeconfig file not found at expected location"
                                     echo "Current directory contents:"
                                     ls -la
                                     echo "Kubeconfig directory contents:"
                                     ls -la kubeconfig/ || echo "Kubeconfig directory does not exist"
                                     exit 1
                                 fi
                             """

                             sh """
                                    echo "=== SCHEMA CONFIGURATION VERIFICATION ==="
                                 grep "default_schema" src/main/resources/application.properties || echo "ERROR: default_schema not found!"
"""
                        }
                    }
                }
            }
        }

        stage('Build Application') {
            steps {
                dir('inventory') {
                    sh 'mvn clean package -DskipTests'
                }
            }
        }

        stage('Build Docker Image') {
            steps {
                script {
                    def imageName = "${params.DOCKER_USER}/inventory-${params.TENANT_NAME}-${params.APP_NAME}:${UUID.randomUUID().toString()}".toLowerCase()
                    def jarFile = "inventory/target/inventory-0.0.1-SNAPSHOT.jar"
                    
                    // Log Docker build information
                    echo "=========================================="
                    echo "DOCKER BUILD INFORMATION"
                    echo "=========================================="
                    echo ""
                    echo "üê≥ DOCKER CONFIGURATION:"
                    echo "  DOCKER_USER: ${params.DOCKER_USER}"
                    echo "  TENANT_NAME: ${params.TENANT_NAME}"
                    echo "  APP_NAME: ${params.APP_NAME}"
                    echo "  IMAGE_NAME: ${imageName}"
                    echo "  JAR_FILE: ${jarFile}"
                    echo ""
                    echo "=========================================="
                    echo "END OF DOCKER BUILD INFORMATION"
                    echo "=========================================="
                    
                    // Create Dockerfile with kubeconfig path
                    sh """
                        # Check if kubeconfig was created successfully
                        if [ -f inventory/kubeconfig/tulip-sandbox-kubeconfig.yaml ]; then
                            echo "Kubeconfig file found at: inventory/kubeconfig/tulip-sandbox-kubeconfig.yaml"
                            ls -la inventory/kubeconfig/
                        else
                            echo "ERROR: Kubeconfig file not found at expected location"
                            echo "Checking inventory directory:"
                            ls -la inventory/ || echo "Inventory directory does not exist"
                            exit 1
                        fi
                    """
                    
                    // Create Dockerfile
                    writeFile file: 'Dockerfile', text: """
FROM openjdk:17-jdk-slim

# Install curl for debugging and health checks
RUN apt-get update && apt-get install -y curl && rm -rf /var/lib/apt/lists/*

# Set working directory
WORKDIR /app

# Copy the JAR file
COPY ${jarFile} app.jar

# Copy the kubeconfig file
COPY inventory/kubeconfig/tulip-sandbox-kubeconfig.yaml /app/kubeconfig/tulip-sandbox-kubeconfig.yaml

# Create necessary directories
RUN mkdir -p /app/logs /app/data /app/uploads /app/kubeconfig

# Expose port
EXPOSE 8080

# Set environment variables
ENV SPRING_PROFILES_ACTIVE=${params.ENVIRONMENT_NAME}
ENV SERVER_PORT=8080

# Run the application
CMD ["java", "-jar", "app.jar"]
"""
                    
                    // Build Docker image
                    docker.build(imageName)
                    
                    // Store image name for later use
                    env.DOCKER_IMAGE = imageName
                }
            }
        }

        stage('Push Docker Image') {
            steps {
                script {
                    withCredentials([string(credentialsId: 'DOCKER_TOKEN', variable: 'DOCKER_TOKEN')]) {
                        sh """
                            echo "$DOCKER_TOKEN" | docker login -u ${params.DOCKER_USER} --password-stdin
                            docker push ${env.DOCKER_IMAGE}
                        """
                    }
                }
            }
        }

        stage('Deploy to Kubernetes') {
            when {
                expression { params.TENANT_NAME != '' }
            }
            steps {
                script {
                    // Create Kubernetes deployment manifest with persistent volume
                    def k8sNamespace = (params.K8S_NAMESPACE && params.K8S_NAMESPACE.trim() != '') ? params.K8S_NAMESPACE : "tenant-${params.TENANT_NAME.toLowerCase().replaceAll('[^a-z0-9-]', '-')}"

                    withCredentials(
                       [string(credentialsId: 'DO_DOMAIN', variable: 'DO_DOMAIN')]
                       ) {




                    echo "Constructed Kubernetes namespace: ${k8sNamespace}"
                    echo "TENANT_NAME parameter: ${params.TENANT_NAME}"
                    echo "K8S_NAMESPACE parameter: '${params.K8S_NAMESPACE}'"
                    echo "K8S_NAMESPACE parameter length: ${params.K8S_NAMESPACE?.length() ?: 'null'}"
                    echo "Workspace directory: ${WORKSPACE}"
                    echo "LoadBalancer name (workspace root): ${WORKSPACE.split('/').last()}"
                    def deploymentYaml = """
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: inventory-${params.TENANT_NAME}-uploads-pvc
  namespace: ${k8sNamespace}
  labels:
    app: inventory
    tenant: ${params.TENANT_NAME}
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 10Gi
  storageClassName: do-block-storage
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: inventory-${params.TENANT_NAME}
  namespace: ${k8sNamespace}
  labels:
    app: inventory
    tenant: ${params.TENANT_NAME}
spec:
  replicas: 1
  selector:
    matchLabels:
      app: inventory
      tenant: ${params.TENANT_NAME}
  template:
    metadata:
      labels:
        app: inventory
        tenant: ${params.TENANT_NAME}
    spec:
      serviceAccountName: ${params.TENANT_NAME}-admin
      containers:
      - name: inventory
        image: ${env.DOCKER_IMAGE}
        ports:
        - containerPort: 8080
        env:
        - name: SPRING_PROFILES_ACTIVE
          value: "${params.ENVIRONMENT_NAME}"
        - name: SERVER_PORT
          value: "8080"
        resources:
          requests:
            memory: "512Mi"
            cpu: "250m"
          limits:
            memory: "1Gi"
            cpu: "500m"
        volumeMounts:
        - name: logs
          mountPath: /app/logs
        - name: data
          mountPath: /app/data
        - name: uploads
          mountPath: /app/uploads
      volumes:
      - name: logs
        emptyDir: {}
      - name: data
        emptyDir: {}
      - name: uploads
        persistentVolumeClaim:
          claimName: inventory-${params.TENANT_NAME}-uploads-pvc
---
        apiVersion: v1
        kind: Service
        metadata:
          name: inventory-${params.TENANT_NAME}-service
          namespace: ${k8sNamespace}
          labels:
            app: inventory
            tenant: ${params.TENANT_NAME}
          annotations:
            service.beta.kubernetes.io/do-loadbalancer-name: "${WORKSPACE.split('/').last()}"
            service.beta.kubernetes.io/do-loadbalancer-algorithm: "round_robin"
            service.beta.kubernetes.io/do-loadbalancer-protocol: "http"
            service.beta.kubernetes.io/do-loadbalancer-tls-passthrough: "false"
            service.beta.kubernetes.io/do-loadbalancer-certificate-id: "${params.TENANT_NAME}.${DO_DOMAIN}"
            service.beta.kubernetes.io/do-loadbalancer-enable-proxy-protocol: "true"
            # Health check configuration - CRITICAL: Use HTTP protocol and port 8080
            service.beta.kubernetes.io/do-loadbalancer-healthcheck-protocol: "http"
            service.beta.kubernetes.io/do-loadbalancer-healthcheck-port: "8080"
            service.beta.kubernetes.io/do-loadbalancer-healthcheck-path: "/login"
            service.beta.kubernetes.io/do-loadbalancer-healthcheck-check-interval-seconds: "10"
            service.beta.kubernetes.io/do-loadbalancer-healthcheck-response-timeout-seconds: "5"
            service.beta.kubernetes.io/do-loadbalancer-healthcheck-healthy-threshold: "3"
            service.beta.kubernetes.io/do-loadbalancer-healthcheck-unhealthy-threshold: "3"
            # Forwarding rules configuration - CRITICAL: Route to port 8080 (single-line JSON format)
            #Force HTTP forwarding rules explicitly
            service.beta.kubernetes.io/do-loadbalancer-forwarding-rules: |
              [
                {
                  "entry_protocol": "http",
                  "entry_port": 80,
                  "target_protocol": "http",
                  "target_port": 8080
                },
                {
                  "entry_protocol": "https",
                  "entry_port": 443,
                  "target_protocol": "http",
                  "target_port": 8080
                }
              ]
            # REMOVED: kubernetes.digitalocean.com/load-balancer-id annotation
            # This allows Kubernetes to use existing LoadBalancer or create new one
        spec:
          type: LoadBalancer
          externalTrafficPolicy: Local
          selector:
            app: inventory
            tenant: ${params.TENANT_NAME}
          ports:
          - name: http
            port: 80
            targetPort: 8080
            protocol: TCP
          - name: https
            port: 443
            targetPort: 8080
            protocol: TCP
"""
                    
                    // Write deployment manifest to file
                    writeFile file: 'k8s-deployment.yaml', text: deploymentYaml
                    }
                    
                    // Apply the deployment using kubectl with file credential
                    withCredentials(
                    [file(credentialsId: 'KUBECONFIG_PATH', variable: 'KCFG'),
                    string(credentialsId: 'DO_DOMAIN', variable: 'DO_DOMAIN')]
                    ) {
                        sh """
                            export KUBECONFIG="\$KCFG"
                            
                            # Verify kubectl can connect to the cluster
                            kubectl config get-contexts
                            
                            # Force delete and recreate service to remove stale LoadBalancer annotations
                            echo "Force deleting any existing service with stale LoadBalancer annotations..."
                            
                            # Force delete the existing service completely
                            echo "Deleting existing service: inventory-${params.TENANT_NAME}-service"
                            kubectl delete service inventory-${params.TENANT_NAME}-service -n ${k8sNamespace} --ignore-not-found=true
                            
                            # Wait for complete deletion
                            echo "Waiting for service deletion to complete..."
                            sleep 10
                            
                            # Verify service is gone
                            if kubectl get service inventory-${params.TENANT_NAME}-service -n ${k8sNamespace} >/dev/null 2>&1; then
                                echo "Service still exists, waiting longer..."
                                sleep 20
                                
                                # Try force delete again if still exists
                                kubectl delete service inventory-${params.TENANT_NAME}-service -n ${k8sNamespace} --force --grace-period=0 || true
                                sleep 5
                            fi
                            
                            echo "Service cleanup completed, ready to create fresh service"
                            kubectl cluster-info
                            
                            # Check if the service account exists in the namespace
                            echo "DEBUG: k8sNamespace variable = ${k8sNamespace}"
                            echo "Checking for service account ${params.TENANT_NAME}-admin in namespace ${k8sNamespace}"
                            kubectl get serviceaccount ${params.TENANT_NAME}-admin -n ${k8sNamespace} || {
                                echo "ERROR: Service account ${params.TENANT_NAME}-admin not found in namespace ${k8sNamespace}"
                                echo "Available service accounts in namespace ${k8sNamespace}:"
                                kubectl get serviceaccounts -n ${k8sNamespace}
                                exit 1
                            }
                            
                            # Apply the deployment
                            kubectl apply -f k8s-deployment.yaml
                            kubectl rollout status deployment/inventory-${params.TENANT_NAME} -n ${k8sNamespace} --timeout=300s
                            
                            # LoadBalancer will be created by Jenkins job - no need to wait for external IP
                            echo "LoadBalancer service created successfully"
                            echo "DNS record will be created after LoadBalancer is provisioned"
                            
                            # Debug: Check service configuration and load balancer details
                            echo "=== Service Configuration ==="
                            kubectl get service inventory-${params.TENANT_NAME}-service -n ${k8sNamespace} -o yaml
                            
                            echo "=== Load Balancer ID ==="
                            LB_ID=\$(kubectl get service inventory-${params.TENANT_NAME}-service -n ${k8sNamespace} -o jsonpath='{.metadata.annotations.kubernetes\\.digitalocean\\.com/load-balancer-id}')
                            echo "Load Balancer ID: \$LB_ID"
                            
                            echo "=== Node Information ==="
                            kubectl get nodes -o wide
                            
                            echo "=== Pod Status ==="
                            kubectl get pods -n ${k8sNamespace} -o wide
                            
                        """
                    }
                }
            }
        }

        stage('Create DNS Record') {
            when {
                expression { params.TENANT_NAME != '' }
            }
            steps {
                script {
                    withCredentials([
                        string(credentialsId: 'DO_API_TOKEN', variable: 'DO_API_TOKEN'),
                        string(credentialsId: 'DO_DOMAIN', variable: 'DO_DOMAIN'),
                        file(credentialsId: 'KUBECONFIG_PATH', variable: 'KCFG')
                    ]) {
                        sh """
                            export KUBECONFIG="\$KCFG"
                            
                            # Get LoadBalancer external IP and create DNS record
                            echo "Getting LoadBalancer external IP for DNS record creation..."
                            
                            # Wait for LoadBalancer to get external IP
                            timeout=300  # 5 minutes timeout
                            while [ \$timeout -gt 0 ]; do
                                EXTERNAL_IP=\$(kubectl get service inventory-${params.TENANT_NAME}-service -n tenant-${params.TENANT_NAME} -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
                                if [ -n "\$EXTERNAL_IP" ] && [ "\$EXTERNAL_IP" != "null" ]; then
                                    echo "LoadBalancer external IP: \$EXTERNAL_IP"
                                    break
                                fi
                                echo "Waiting for external IP... (\$timeout seconds remaining)"
                                sleep 10
                                timeout=\$((timeout - 10))
                            done
                            
                            if [ -n "\$EXTERNAL_IP" ] && [ "\$EXTERNAL_IP" != "null" ]; then
                                echo "Creating DNS record for ${params.TENANT_NAME}.${DO_DOMAIN} -> \$EXTERNAL_IP"
                                curl -X POST "https://api.digitalocean.com/v2/domains/${DO_DOMAIN}/records" \\
                                    -H "Content-Type: application/json" \\
                                    -H "Authorization: Bearer \$DO_API_TOKEN" \\
                                    -d '{
                                        "type": "A",
                                        "name": "${params.TENANT_NAME}",
                                        "data": "\$EXTERNAL_IP",
                                        "ttl": 60
                                    }'
                                
                                echo "DNS record creation completed"
                            else
                                echo "ERROR: LoadBalancer did not get external IP within timeout"
                                exit 1
                            fi
                                
                                # Ensure node is added to the load balancer
                                echo "=== Adding node to load balancer ==="
                                LB_ID=\$(kubectl get service inventory-${params.TENANT_NAME}-service -n tenant-${params.TENANT_NAME} -o jsonpath='{.metadata.annotations.kubernetes\\.digitalocean\\.com/load-balancer-id}')
                                if [ -n "\$LB_ID" ]; then
                                    echo "Load Balancer ID: \$LB_ID"
                                    
                                    # Get node droplet ID (assuming single node cluster)
                                    NODE_NAME=\$(kubectl get nodes -o jsonpath='{.items[0].metadata.name}')
                                    echo "Node Name: \$NODE_NAME"
                                    
                                    # Manually add the droplet to the load balancer
                                    # This fixes the issue where CCM doesn't automatically add nodes
                                    echo "Adding droplet 516774967 to load balancer \$LB_ID"
                                    curl -X POST \\
                                      "https://api.digitalocean.com/v2/load_balancers/\$LB_ID/droplets" \\
                                      -H "Content-Type: application/json" \\
                                      -H "Authorization: Bearer \$DO_API_TOKEN" \\
                                      -d '{"droplet_ids": [516774967]}'
                                    
                                    if [ \$? -eq 0 ]; then
                                        echo "‚úÖ Node successfully added to load balancer"
                                        
                                        # Verify the node was added by checking the load balancer details
                                        echo "Verifying node addition..."
                                        sleep 5  # Wait a moment for the API to update
                                        
                                        # Check if the droplet is now in the load balancer
                                        DROPLET_CHECK=\$(curl -s -H "Authorization: Bearer \$DO_API_TOKEN" \\
                                          "https://api.digitalocean.com/v2/load_balancers/\$LB_ID" | \\
                                          grep -o "516774967" || echo "not_found")
                                        
                                        if [ "\$DROPLET_CHECK" = "516774967" ]; then
                                            echo "‚úÖ Verification successful: Droplet 516774967 is now in the load balancer"
                                        else
                                            echo "‚ö†Ô∏è  Verification failed: Droplet may not be visible yet (this can take a few minutes)"
                                        fi
                                    else
                                        echo "‚ùå Failed to add node to load balancer"
                                    fi
                                    
                                    echo "Note: This manual addition fixes the CCM issue where nodes aren't automatically added"
                                    
                                    # LoadBalancer created with correct configuration from start
                                    echo "=== LoadBalancer Created Successfully ==="
                                    echo "LoadBalancer ID: \$LB_ID"
                                    echo "LoadBalancer Name: ${WORKSPACE.split('/').last()}"
                                    echo "‚úÖ LoadBalancer created with correct configuration"
                                    
                                    # Check application health
                                    echo "=== Checking application health ==="
                                    POD_NAME=\$(kubectl get pods -n tenant-${params.TENANT_NAME} -l app=inventory -o jsonpath='{.items[0].metadata.name}')
                                    if [ -n "\$POD_NAME" ]; then
                                        echo "Testing /login endpoint (LoadBalancer health check path)..."
                                        kubectl exec -n tenant-${params.TENANT_NAME} \$POD_NAME -- curl -f http://localhost:8080/login || echo "Login endpoint check failed - app may still be starting"
                                        
                                        echo "Testing /actuator/health endpoint..."
                                        kubectl exec -n tenant-${params.TENANT_NAME} \$POD_NAME -- curl -f http://localhost:8080/actuator/health || echo "Actuator health check failed - may require authentication"
                                    fi
                                    
                                    # Check LoadBalancer health status
                                    echo "=== Checking LoadBalancer health status ==="
                                    echo "LoadBalancer configuration (FIXED):"
                                    echo "  Forwarding Rules:"
                                    echo "    - HTTP (port 80) ‚Üí HTTP (port 8080)"
                                    echo "    - HTTPS (port 443) ‚Üí HTTP (port 8080)"
                                    echo "  Health Check:"
                                    echo "    - Protocol: HTTP (NOT TCP)"
                                    echo "    - Port: 8080 (NOT 80)"
                                    echo "    - Path: /login (Spring Security bypass)"
                                    echo "    - Check interval: 10 seconds"
                                    echo "    - Response timeout: 5 seconds"
                                    echo "    - Healthy threshold: 3 consecutive successes"
                                    echo "    - Unhealthy threshold: 3 consecutive failures"
                                    echo ""
                                    echo "CRITICAL: LoadBalancer now properly forwards traffic to port 8080"
                                    echo "CRITICAL: Health checks are now configured for HTTP on port 8080"
                                    echo "Note: Using /login endpoint to bypass Spring Security authentication"
                                    echo "Note: It may take 1-2 minutes for the node to show as 'Up' after health checks pass"
                                else
                                    echo "Warning: Load Balancer ID not found in service annotations"
                                fi
                        """
                    }
                }
            }
        }
    }

    post {
        success {
            echo "Deployment completed successfully for tenant: ${params.TENANT_NAME}"
            echo "Docker image: ${env.DOCKER_IMAGE}"
            script {
                def k8sNamespace = params.K8S_NAMESPACE ?: "tenant-${params.TENANT_NAME.toLowerCase().replaceAll('[^a-z0-9-]', '-')}"
                echo "Kubernetes namespace: ${k8sNamespace}"
            }
        }
        failure {
            echo "Deployment failed for tenant: ${params.TENANT_NAME}"
        }
        always {
            // Clean up temporary files
            sh 'rm -f Dockerfile k8s-deployment.yaml'
        }
        
        stage('Attach Certificate and Create DNS') {
            when {
                expression { params.TENANT_NAME != '' }
            }
            steps {
                script {
                    withCredentials([
                        string(credentialsId: 'DO_API_TOKEN', variable: 'DO_API_TOKEN'),
                        string(credentialsId: 'DO_DOMAIN', variable: 'DO_DOMAIN'),
                        file(credentialsId: 'KUBECONFIG_PATH', variable: 'KCFG')
                    ]) {
                        sh """
                            export KUBECONFIG="\$KCFG"
                            
                            echo "=== Attaching Certificate and Creating DNS Record ==="
                            
                            # Get LoadBalancer ID from Kubernetes service
                            LB_ID=\$(kubectl get service inventory-${params.TENANT_NAME}-service -n tenant-${params.TENANT_NAME} -o jsonpath='{.metadata.annotations.kubernetes\\.digitalocean\\.com/load-balancer-id}')
                            
                            if [ -z "\$LB_ID" ]; then
                                echo "ERROR: Could not find LoadBalancer ID from Kubernetes service"
                                exit 1
                            fi
                            
                            echo "LoadBalancer ID: \$LB_ID"
                            
                            # Get LoadBalancer external IP
                            EXTERNAL_IP=\$(kubectl get service inventory-${params.TENANT_NAME}-service -n tenant-${params.TENANT_NAME} -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
                            
                            if [ -z "\$EXTERNAL_IP" ] || [ "\$EXTERNAL_IP" = "null" ]; then
                                echo "ERROR: Could not get LoadBalancer external IP"
                                exit 1
                            fi
                            
                            echo "LoadBalancer external IP: \$EXTERNAL_IP"
                            
                            # Find certificate ID for the domain
                            echo "Finding certificate for domain: ${params.TENANT_NAME}.${DO_DOMAIN}"
                            CERT_ID=\$(curl -s -H "Authorization: Bearer \$DO_API_TOKEN" \\
                              "https://api.digitalocean.com/v2/certificates" | \\
                              jq -r ".certificates[] | select(.dns_names[] == \"${params.TENANT_NAME}.${DO_DOMAIN}\") | .id")
                            
                            if [ -z "\$CERT_ID" ] || [ "\$CERT_ID" = "null" ]; then
                                echo "ERROR: No certificate found for domain: ${params.TENANT_NAME}.${DO_DOMAIN}"
                                exit 1
                            fi
                            
                            echo "Found certificate ID: \$CERT_ID"
                            
                            # Get current LoadBalancer configuration
                            echo "Getting current LoadBalancer configuration..."
                            LB_CONFIG=\$(curl -s -H "Authorization: Bearer \$DO_API_TOKEN" \\
                              "https://api.digitalocean.com/v2/load_balancers/\$LB_ID")
                            
                            if [ \$? -ne 0 ]; then
                                echo "ERROR: Failed to get LoadBalancer configuration"
                                exit 1
                            fi
                            
                            # Extract current configuration
                            LB_NAME=\$(echo "\$LB_CONFIG" | jq -r '.load_balancer.name')
                            LB_ALGORITHM=\$(echo "\$LB_CONFIG" | jq -r '.load_balancer.algorithm')
                            LB_REGION=\$(echo "\$LB_CONFIG" | jq -r '.load_balancer.region.slug')
                            LB_SIZE=\$(echo "\$LB_CONFIG" | jq -r '.load_balancer.size')
                            LB_SIZE_UNIT=\$(echo "\$LB_CONFIG" | jq -r '.load_balancer.size_unit')
                            
                            echo "LoadBalancer details:"
                            echo "  Name: \$LB_NAME"
                            echo "  Algorithm: \$LB_ALGORITHM"
                            echo "  Region: \$LB_REGION"
                            echo "  Size: \$LB_SIZE"
                            echo "  Size Unit: \$LB_SIZE_UNIT"
                            
                            # Update LoadBalancer with certificate attached to HTTPS rule
                            echo "Attaching certificate to LoadBalancer..."
                            curl -X PUT \\
                              "https://api.digitalocean.com/v2/load_balancers/\$LB_ID" \\
                              -H "Content-Type: application/json" \\
                              -H "Authorization: Bearer \$DO_API_TOKEN" \\
                              -d '{
                                "name": "\$LB_NAME",
                                "algorithm": "\$LB_ALGORITHM",
                                "region": "\$LB_REGION",
                                "size": "\$LB_SIZE",
                                "size_unit": \$LB_SIZE_UNIT,
                                "forwarding_rules": [
                                  {
                                    "entry_protocol": "http",
                                    "entry_port": 80,
                                    "target_protocol": "http",
                                    "target_port": 8080,
                                    "tls_passthrough": false
                                  },
                                  {
                                    "entry_protocol": "https",
                                    "entry_port": 443,
                                    "target_protocol": "http",
                                    "target_port": 8080,
                                    "tls_passthrough": false,
                                    "certificate_id": "\$CERT_ID"
                                  }
                                ],
                                "health_check": {
                                  "protocol": "http",
                                  "port": 8080,
                                  "path": "/login",
                                  "check_interval_seconds": 10,
                                  "response_timeout_seconds": 5,
                                  "healthy_threshold": 3,
                                  "unhealthy_threshold": 3
                                }
                              }'
                            
                            if [ \$? -eq 0 ]; then
                                echo "‚úÖ Certificate successfully attached to LoadBalancer"
                            else
                                echo "‚ùå Failed to attach certificate to LoadBalancer"
                                exit 1
                            fi
                            
                            # Create DNS A record
                            echo "Creating DNS A record for ${params.TENANT_NAME}.${DO_DOMAIN} -> \$EXTERNAL_IP"
                            curl -X POST "https://api.digitalocean.com/v2/domains/${DO_DOMAIN}/records" \\
                              -H "Content-Type: application/json" \\
                              -H "Authorization: Bearer \$DO_API_TOKEN" \\
                              -d '{
                                "type": "A",
                                "name": "${params.TENANT_NAME}",
                                "data": "\$EXTERNAL_IP",
                                "ttl": 60
                              }'
                            
                            if [ \$? -eq 0 ]; then
                                echo "‚úÖ DNS A record created successfully"
                                echo "Domain: ${params.TENANT_NAME}.${DO_DOMAIN}"
                                echo "IP: \$EXTERNAL_IP"
                                echo "Certificate: \$CERT_ID"
                            else
                                echo "‚ùå Failed to create DNS A record"
                                exit 1
                            fi
                            
                            echo "=== Certificate and DNS Setup Complete ==="
                        """
                    }
                }
            }
        }
    }
}
