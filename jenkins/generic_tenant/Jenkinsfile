// Add to your Jenkinsfile as a separate pipeline

//8. Complete Integration Flow:
//   Customer signs up → Payment processed via Stripe
//   Paypal webhook → Triggers tenant provisioning pipeline
//   Jenkins pipeline → Creates namespace, deploys app, configures domain
//   DNS propagation → Tenant gets their subdomain
//   SSL certificate → Automatically provisioned via cert-manager
//   Welcome email → Sent with login credentials
//   This approach gives you automated multi-tenant provisioning with proper resource isolation, billing integration, and scalable infrastructure management.


pipeline {
    agent {
        docker {
            image 'postgres:16'   // official postgres image includes psql
            args '-u root:root'   // run as root to install if needed
        }
    }

    parameters {
        string(name: 'TENANT_NAME', description: 'New tenant identifier')
        string(name: 'BILLING_EMAIL', description: 'Tenant billing email')
        choice(name: 'SUBSCRIPTION_TIER', choices: ['basic', 'pro', 'enterprise'])
        string(name: 'SANDBOX_POSTGRESQL_URI', description: 'Sandbox PostgreSQL URI')
        string(name: 'SANDBOX_POSTGRESQL_USER', description: 'Sandbox PostgreSQL User')
        string(name: 'SANDBOX_POSTGRESQL_PUBLIC_URI', description: 'Sandbox PostgreSQL Public URI')
        string(name: 'SANDBOX_POSTGRESQL_PUBLIC_USER', description: 'Sandbox PostgreSQL Public User')
    }

    environment {
        // Jenkins secrets for PostgreSQL credentials
        SANDBOX_POSTGRESQL_PASSWORD = credentials('SANDBOX_POSTGRESQL_PASSWORD')
    }

    stages {
        stage('Validate Tenant') {
            steps {
                script {
                // do the follwing in a java adhoc scheduled job
                    // Check if tenant name is available
                    // Validate domain requirements
                    // Verify payment completion
                }
            }
        }

        stage('Test Database Connection') {
            steps {
                script {
                    sh """
                        echo "Testing connection to sandbox PostgreSQL..."
                        
                        # Set PostgreSQL connection parameters
                        export PGHOST="${params.SANDBOX_POSTGRESQL_PUBLIC_URI}"
                        export PGUSER="${params.SANDBOX_POSTGRESQL_PUBLIC_USER}"
                        export PGPASSWORD="${SANDBOX_POSTGRESQL_PASSWORD}"
                        export PGDATABASE="defaultdb"
                        
                        # Test connection with a simple query
                        psql -c "SELECT NOW() as current_time, current_database() as database_name, current_user as user_name;"
                        
                        echo "Database connection test successful"
                    """
                }
            }
        }

        stage('Create Tenant Namespace') {
            steps {
                script {
                    sh """
                        kubectl create namespace tenant-${params.TENANT_NAME}
                        kubectl label namespace tenant-${params.TENANT_NAME} tenant=${params.TENANT_NAME}
                        kubectl label namespace tenant-${params.TENANT_NAME} tier=${params.SUBSCRIPTION_TIER}
                    """
                }
            }
        }

        stage('Create Tenant Schema') {
            steps {
                script {
                    sh """
                        echo "Creating schema for tenant: ${params.TENANT_NAME}"
                        
                        # Set PostgreSQL connection parameters
                        export PGHOST="${params.SANDBOX_POSTGRESQL_PUBLIC_URI}"
                        export PGUSER="${params.SANDBOX_POSTGRESQL_PUBLIC_USER}"
                        export PGPASSWORD="${SANDBOX_POSTGRESQL_PASSWORD}"
                        export PGDATABASE="defaultdb"
                        
                        # Create schema for the new tenant
                        psql -c "CREATE SCHEMA IF NOT EXISTS tenant_${params.TENANT_NAME};"
                        
                        # Grant permissions to the schema
                        psql -c "GRANT ALL PRIVILEGES ON SCHEMA tenant_${params.TENANT_NAME} TO ${params.SANDBOX_POSTGRESQL_PUBLIC_USER};"
                        
                        # Set default privileges for future objects in the schema
                        psql -c "ALTER DEFAULT PRIVILEGES IN SCHEMA tenant_${params.TENANT_NAME} GRANT ALL ON TABLES TO ${params.SANDBOX_POSTGRESQL_PUBLIC_USER};"
                        psql -c "ALTER DEFAULT PRIVILEGES IN SCHEMA tenant_${params.TENANT_NAME} GRANT ALL ON SEQUENCES TO ${params.SANDBOX_POSTGRESQL_PUBLIC_USER};"
                        
                        # Verify schema creation
                        psql -c "\\dn tenant_${params.TENANT_NAME}"
                        
                        echo "Schema tenant_${params.TENANT_NAME} created successfully"
                        
                        # Set tenant-specific DB_URI for application deployment
                        export TENANT_DB_URI="jdbc:postgresql://${params.SANDBOX_POSTGRESQL_PUBLIC_URI}/defaultdb?currentSchema=tenant_${params.TENANT_NAME}"
                        export TENANT_DB_SCHEMA="tenant_${params.TENANT_NAME}"
                    """
                }
            }
        }


        stage('Configure Domain') {
            steps {
                script {
                    sh """
                        # Update DNS (using your DNS provider API)
                        curl -X POST "https://api.cloudflare.com/client/v4/zones/${ZONE_ID}/dns_records" \
                        -H "Authorization: Bearer ${CF_API_TOKEN}" \
                        -d '{"type":"CNAME","name":"${params.TENANT_NAME}","content":"${LOAD_BALANCER_IP}"}'

                        # Cert-manager will automatically provision SSL certificates
                        kubectl apply -f - <<EOF
        apiVersion: cert-manager.io/v1
        kind: Certificate
        metadata:
          name: ${params.TENANT_NAME}-tls
          namespace: tenant-${params.TENANT_NAME}
        spec:
          secretName: ${params.TENANT_NAME}-tls
          dnsNames:
          - ${params.TENANT_NAME}.yoursaas.com
          issuerRef:
            name: letsencrypt-prod
            kind: ClusterIssuer
        EOF
                    """
                }
            }
        }

        stage('Deploy Tenant Application') {
            steps {
                script {
                    // Trigger your main deployment pipeline with tenant-specific params
                    build job: 'kubernetes-app-deployment', parameters: [
                        string(name: 'APP_NAME', value: params.APP_NAME),
                        string(name: 'K8S_NAMESPACE', value: "tenant-${params.TENANT_NAME}"),
                        string(name: 'TENANT_NAME', value: params.TENANT_NAME),
                        string(name: 'BASE_DOMAIN', value: '.yoursaas.com')
                    ]
                }
            }
        }
    }
}